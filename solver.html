<!DOCTYPE html>
<html>
<head>
	<title>GTNH TC Research Solver</title>
	<!--Thaumcraft research minigame solver using heuristics and bruteforce-->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<style>
		#canvas {
			/* border: solid 1px; */
		}
		body {
			/*background-color: #232327;*/
			font-family: Helvetica Neue, Helvetica;
		}

		.aspect_content_wrapper {
			/*width: 100px;
			height: 60px;*/
			width: 10%;
			height: 60px;
			border: solid;
			border-color: black;
			display: flex;
			align-items: flex-start;
			margin-bottom: 3%;
		}

		.aspect_content_wrapper img {
			/*height: 100%;*/
			width: 35%;
			padding-right: 10%;
			-webkit-user-drag: none;
			-khtml-user-drag: none;
			-moz-user-drag: none;
			-o-user-drag: none;
			user-drag: none;
		}

		.aspect_text_wrapper {
			display: flex;
			flex-direction: column;
			justify-content: space-between;
		}

		#aspect_selector_gui {
			width: 95%;
		}
		
	</style>
</head>
<body onload="load_aspect_selector()">
	<canvas id='canvas' onclick="handle_click(event)"></canvas>
	<br>
	<div id="aspect_selector_gui" style="display: flex; flex-wrap: wrap; justify-content: space-around;"></div>
	<br>
	<button onclick='mouse_selection_mode()'>Selection mode (for choosing aspects)</button>
	<br>
	<button onclick='mouse_barring_mode()'>Barring mode (bar the cells that aren't available)</button>
	<br>
	<select id="aspect_selector" onchange="assign_aspect()">
		<option value="none">Aspect - none</option>
		<option value="aer">Aer</option>
		<option value="alienis">Alienis</option>
		<option value="aqua">Aqua</option>
		<option value="arbor">Arbor</option>
		<option value="auram">Auram</option>
		<option value="bestia">Bestia</option>
		<option value="cognitio">Cognitio</option>
		<option value="corpus">Corpus</option>
		<option value="exanimis">Exanimis</option>
		<option value="fabrico">Fabrico</option>
		<option value="fames">Fames</option>
		<option value="gelum">Gelum</option>
		<option value="herba">Herba</option>
		<option value="humanus">Humanus</option>
		<option value="ignis">Ignis</option>
		<option value="instrumentum">Instrumentum</option>
		<option value="iter">Iter</option>
		<option value="limus">Limus</option>
		<option value="lucrum">Lucrum</option>
		<option value="lux">Lux</option>
		<option value="machina">Machina</option>
		<option value="messis">Messis</option>
		<option value="metallum">Metallum</option>
		<option value="meto">Meto</option>
		<option value="mortuus">Mortuus</option>
		<option value="motus">Motus</option>
		<option value="ordo">Ordo</option>
		<option value="pannus">Pannus</option>
		<option value="perditio">Perditio</option>
		<option value="perfodio">Perfodio</option>
		<option value="permutatio">Permutatio</option>
		<option value="potentia">Potentia</option>
		<option value="praecantatio">Praecantatio</option>
		<option value="sano">Sano</option>
		<option value="sensus">Sensus</option>
		<option value="spiritus">Spiritus</option>
		<option value="telum">Telum</option>
		<option value="tempestas">Tempestas</option>
		<option value="tenebrae">Tenebrae</option>
		<option value="terra">Terra</option>
		<option value="tutamen">Tutamen</option>
		<option value="vacuos">Vacuos</option>
		<option value="venenum">Venenum</option>
		<option value="victus">Victus</option>
		<option value="vinculum">Vinculum</option>
		<option value="vitium">Vitium</option>
		<option value="vitreus">Vitreus</option>
		<option value="volatus">Volatus</option>

		<option value="none">===============</option>

		<option value="desidia">Desidia</option>
		<option value="gula">Gula</option>
		<option value="infernus">Infernus</option>
		<option value="invidia">Invidia</option>
		<option value="ira">Ira</option>
		<option value="luxuria">Luxuria</option>
		<option value="superbia">Superbia</option>

		<option value="none">===============</option>

		<option value="tempus">Tempus</option>

		<option value="none">===============</option>

		<option value="electrum">Electrum</option>
		<option value="magneto">Magneto</option>
		<option value="nebrisum">Nebrisum</option>
		<option value="radio">Radio</option>
		<option value="strontio">Strontio</option>

		<option value="none">===============</option>

		<option value="terminus">Terminus</option>

		<!--<option value="none">===============</option>

		<option value="sagrausten">Sagrausten</option>
		<option value="slusium">Slusium</option>
		<option value="xablum">Xablum</option>
		<option value="xenil">Xenil</option>
		<option value="zetralt">Zetralt</option>-->
	</select>
	<br>
	<button onclick="solve()">Solve</button>
	<br><br>
	<button onclick="preset(7)">preset (debug)</button>
	<br><br>
	<input type="number" name="Grid size" onchange="resize_grid()" id="grid_size_input" value="5">
	<h2 id="loading">Please wait, loading aspect images...</h2>
	<div id="gui_aspect_selector"></div>
	<!--<div style="overflow-x:auto;">-->
  
	<div style="position: fixed; z-index: -1; top: 0; left: 0;" id="cursor_placeholder"></div>

	<br><br>
</body>

<script>

	var debugging = false;

	var holding_aspect = false;
	var held_aspect = 'none';
	var last_highlighted_id = null;

	/* detect click outside of canvas */
	document.addEventListener('click', function(event) {
		var isClickInside = document.getElementById('canvas').contains(event.target) || document.getElementById('aspect_selector').contains(event.target);
		if (!isClickInside && selected_cell != undefined) {
			selected_cell.selected = false;
			selected_cell = undefined;
			draw_grid(grid);
		}
	});

	var image_cache = {};

	/* util functions, going into separate file later */

	function get_mouse_pos_canvas(canvas, evt) {
		let rect = canvas.getBoundingClientRect();
		return {
			x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,
			y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height
		}
	}

	/* degrees to radians */
	function to_rad(deg) {
		return deg * Math.PI / 180;
	}

	/* distance between two points */
	function get_distance(x1, y1, x2, y2) {
		return Math.sqrt(Math.abs(x1 - x2) * Math.abs(x1 - x2) + Math.abs(y1 - y2) * Math.abs(y1 - y2));
	}

	/* object handling */
	function keylen(obj) {
		return Object.keys(obj).length;
	}

	function keyAtIndex(obj, index) {
		return Object.keys(obj)[index];
	}

	function elemAtIndex(obj, index) {
		return obj[Object.keys(obj)[index]];
	}

	function obj_expr_xnor(object, expression) {
		if (object === 'undefined') {
			return true;
		} else {
			return expression;
		}
	}

	function capitalize(string) {
		return string[0].toUpperCase() + string.substring(1);
	}

	/*function text_width(text, font) {
	  	let canvas = displayTextWidth.canvas || (displayTextWidth.canvas = document.createElement("canvas"));
	  	let context = canvas.getContext("2d");
	  	context.font = font;
	  	let metrics = context.measureText(text);
	  	return metrics.width;
	}*/

	function text_width(text, font) {
		let text_canvas = document.createElement('canvas');
		let text_ctx = text_canvas.getContext('2d');
		text_ctx.font = font;
		let text_width = text_ctx.measureText(text).width;
		text_canvas.remove();
		return text_width;
	}

	var aspect_flavor_dict = {
			'aer':'air',
			'alienis':'eldritch',
			'aqua':'water',
			'arbor':'none',
			'auram':'aura',
			'bestia':'none',
			'cognitio':'none',
			'corpus':'none',
			'exanimis':'none',
			'fabrico':'none',
			'fames':'none',
			'gelum':'none',
			'herba':'none',
			'humanus':'none',
			'ignis':'none',
			'instrumentum':'none',
			'iter':'none',
			'limus':'none',
			'lucrum':'none',
			'lux':'none',
			'machina':'none',
			'messis':'none',
			'metallum':'none'
		}

	function load_aspect_selector() {
		let aspect_selector_gui = document.getElementById('aspect_selector_gui');
		for (let i = 0; i < keylen(aspect_flavor_dict); i++) {
			let child = '<div id="aspect_content_wrapper_' + i + '" class="aspect_content_wrapper"><img id="aspect_image_' + i + '" src="./hq_images_black_all/' + keyAtIndex(aspect_flavor_dict, i) + '.png"><div class="aspect_text_wrapper" id="aspect_text_' + i + '"><span id="text_' + i + '">' + capitalize(keyAtIndex(aspect_flavor_dict, i)) + '</span><span id="flavor_' + i + '">' + elemAtIndex(aspect_flavor_dict, i) + '<span></div></div>';
			aspect_selector_gui.innerHTML += child;
		}
		
		on_resize();
	}

	document.addEventListener('mousedown', function(event) {
		if (event.target.id.startsWith('aspect_image_')) {
			console.log('clicked ' + keyAtIndex(aspect_flavor_dict, event.target.id.substring(13)));
			document.body.style.cursor /*document.getElementById('aspect_image_0').style.cursor*/ = "url('./cursors/" + keyAtIndex(aspect_flavor_dict, event.target.id.substring(13)) + '.png' + "') 15 15, pointer";
			console.log(document.body.style.cursor);
			holding_aspect = true;
			held_aspect = keyAtIndex(aspect_flavor_dict, event.target.id.substring(13));
			//console.log('<img id="aspect_cursor" src="./hq_images_black_all/' + keyAtIndex(aspect_flavor_dict, event.target.id.substring(13)) + '">');
			/*let aspect_cursor = '<img id="aspect_cursor" style="width: ' + Math.trunc(current_state.grid[0][0].side_len) * 2 + 'px;" src="./hq_images_black_all/' + keyAtIndex(aspect_flavor_dict, event.target.id.substring(13)) + '.png">';
			document.getElementById('cursor_placeholder').innerHTML = aspect_cursor;*/
		}
	});

	document.addEventListener('mouseup', function(event) {
		if (held_aspect != 'none' && last_highlighted_id) {
			let last_highlighted_cell = get_cell_by_id(last_highlighted_id, current_state.grid);
			last_highlighted_cell.highlighted = false;
			last_highlighted_cell.aspect = held_aspect;
			update_cell(current_state.grid, last_highlighted_cell.array_x, last_highlighted_cell.array_y);
		}
		document.body.style.cursor = '';
		holding_aspect = false;
		held_aspect = 'none';
	});

	document.addEventListener('mousemove', function(event) {
		let mouse_in_cell = false;
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				//console.debug(grid[i][j].y);
				console.debug(`acceptable distance: ${grid[i][j].side_len}`);
				let mouse_x = get_mouse_pos_canvas(canvas, event).x;//event.clientX;
				let mouse_y = get_mouse_pos_canvas(canvas, event).y;//event.clientY;
				//console.log(get_mouse_pos_canvas(canvas, event).x);
				let distance = Math.sqrt(Math.pow(Math.abs(grid[i][j].x - mouse_x), 2) + Math.pow(Math.abs(grid[i][j].y - mouse_y), 2));
				if (distance <= grid[i][j].side_len) {
					mouse_in_cell = true;
					current_state.grid[i][j].highlighted = true;
					update_cell(current_state.grid, i, j);
					if (last_highlighted_id == null) {
						last_highlighted_id = current_state.grid[i][j].id;
						console.log('0 last highlighted cell: ' + last_highlighted_id);
					}
					if (current_state.grid[i][j].id != last_highlighted_id) {
						let last_highlighted_cell = get_cell_by_id(last_highlighted_id, current_state.grid);
						last_highlighted_cell.highlighted = false;
						update_cell(current_state.grid, last_highlighted_cell.array_x, last_highlighted_cell.array_y);
						last_highlighted_id = current_state.grid[i][j].id;
						console.log('1 last highlighted cell: ' + last_highlighted_id);
					}
					//draw_grid(current_state.grid);
				} else {
					//current_state.grid[i][j].highlighted = false;
					//draw_grid(current_state.grid);
				}
			}
		}
		if (!mouse_in_cell && last_highlighted_id) {
			let last_highlighted_cell = get_cell_by_id(last_highlighted_id, current_state.grid);
			last_highlighted_cell.highlighted = false;
			update_cell(current_state.grid, last_highlighted_cell.array_x, last_highlighted_cell.array_y);
			last_highlighted_id = null;
		}
		if (holding_aspect) {
			
		}
	});

	function on_resize() {
		for (let i = 0; i < keylen(aspect_flavor_dict); i++) {
			let text = document.getElementById('text_' + i);
			let flavor = document.getElementById('flavor_' + i);
			let image = document.getElementById('aspect_image_' + i);
			flavor.style.fontSize = document.getElementById("aspect_text_" + i).offsetWidth / flavor.offsetWidth * 20 + 'px';
			text.style.fontSize = document.getElementById("aspect_text_" + i).offsetWidth / text.offsetWidth * 30 + 'px';
			while (text_width(text.innerText, text.style.fontSize + ' Helvetica Neue, Helvetica') + image.offsetWidth > document.getElementById('aspect_content_wrapper_' + i).offsetWidth - 5 && text.style.fontSize != '1px') {
				text.style.fontSize = text.style.fontSize.substring(0, 2)[1] != 'p' ? (parseInt(text.style.fontSize.substring(0, 2)) - 1).toString() + 'px' : (parseInt(text.style.fontSize.substring(0, 1)) - 1).toString() + 'px';
			}
			while (text_width(flavor.innerText, flavor.style.fontSize + ' Helvetica Neue, Helvetica') + image.offsetWidth > document.getElementById('aspect_content_wrapper_' + i).offsetWidth - 5 && flavor.style.fontSize != '1px') {
				flavor.style.fontSize = flavor.style.fontSize.substring(0, 2)[1] != 'p' ? (parseInt(flavor.style.fontSize.substring(0, 2)) - 1).toString() + 'px' : (parseInt(flavor.style.fontSize.substring(0, 1)) - 1).toString() + 'px';
			}
		}
	}

	window.onresize = on_resize;

	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');

	function white_canvas() {
		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	class Cell {
		constructor(x, y, aspect, barred, side_len, id, array_x, array_y) {
			this.x = x;
			this.y = y;
			this.aspect = aspect;
			this.barred = barred;
			this.side_len = side_len;
			this.selected = false;
			this.highlighted = false;
			this.img;
			this.base = false;
			this.id = id;
			this.parent_id;
			this.array_x = array_x;
			this.array_y = array_y;
			this.path_child;
			//this.path_parent;
		}
	}

	var distance_dict = {};

	class State {
		constructor(grid) {
			this.grid = grid;
			this.impossible_closest_cells = {};
			this.impossible_aspects_for_current_path = {};
			this.impossible_last_cell_id;
			this.last_move = null;
			this.last_cell = null;
			this.last_cell2 = null;
			this.current_path = null;
			this.blacklisted_paths = []; /* I swear, I'll update my terminology ASAP, straight from the master branch of the political correctness repo */
			this.blacklisted_cells = [];
			this.current_path_child_dict = {};
			this.current_path_child_blacklist = {};
			this.current_path_forbidden_child;
			this.bad_state_reason = null;
		}
	}

	var mouse_mode = 'selecting';
	var selected_cell;

	function mouse_selection_mode() {
		mouse_mode = 'selecting';
	}

	function mouse_barring_mode() {
		mouse_mode = 'barring';
		if (selected_cell != undefined) {
			selected_cell.selected = false;
			selected_cell = undefined;
		}
	}

	function handle_click(event) {
		let mouse_x = get_mouse_pos_canvas(canvas, event).x;//event.clientX;
		let mouse_y = get_mouse_pos_canvas(canvas, event).y;//event.clientY;
		var coords = "X coords: " + mouse_x + ", Y coords: " + mouse_y;
		console.debug(coords);
		var found = false;
		/* loop through all cells in grid and find which one is nearest to the click */
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				//console.debug(grid[i][j].y);
				console.debug(`acceptable distance: ${grid[i][j].side_len}`);
				distance = Math.sqrt(Math.pow(Math.abs(grid[i][j].x - mouse_x), 2) + Math.pow(Math.abs(grid[i][j].y - mouse_y), 2));
				if (distance <= grid[i][j].side_len) {
					found = true;
					console.debug(`found at ${parseFloat(grid[i][j].x).toFixed(2)}, ${parseFloat(grid[i][j].y).toFixed(2)} at distance ${distance}`);
					if (mouse_mode == 'barring') {
						if (grid[i][j].barred) {
							grid[i][j].barred = false;
						} else {
							grid[i][j].selected = false;
							grid[i][j].aspect = 'none';
							grid[i][j].barred = true;
						}
					}
					if (mouse_mode == 'selecting') {
						if (grid[i][j].selected) {
							grid[i][j].selected = false;
						} else if (!grid[i][j].barred) {
							grid[i][j].selected = true;
							if (selected_cell != undefined && selected_cell != grid[i][j]) {
								selected_cell.selected = false;
								selected_cell = undefined;
							}
							selected_cell = grid[i][j];
						}
					}
					break;
				}
			}
		}
		if (!found && selected_cell != undefined) {
			selected_cell.selected = false;
			selected_cell = undefined;
		}
		if (selected_cell != undefined && selected_cell.selected) {
			document.getElementById('aspect_selector').value = selected_cell.aspect;
		}
		draw_grid(grid);
	}

	/* Resizing the canvas 31.25 percent of screen width (400 px if the screen is 1280 px wide) */
	var screen_percentage = 31.25;
	canvas.height = screen.width / 100 * screen_percentage;
	canvas.width = screen.width / 100 * screen_percentage;
	
	/* drawing default size hex grid. Regular hexagon, "size 4" */
	/* the whole grid should always take the maximum space */
	/* a place in the grid should be selected on the canvas and then the aspect that is there must be a html panel below where one can search for the aspect and click to place it */
	var grid_size = 5;

	/* Drawing hexagon at coords */
	function draw_hexagon(x, y, side_len, lineWidth = 1, lineColor = '#000000', fillColor = '#FFFFFF', pointing_up = false) {
		console.debug("side_len: " + side_len)
		side_len -= Math.ceil(lineWidth / 2) + 1;
		var triangle_height = Math.sqrt(Math.pow(side_len, 2) - Math.pow(side_len / 2, 2));
		var points;
		if (pointing_up) {
			points = [[x + triangle_height, y - side_len / 2], [x + triangle_height, y + side_len / 2], [x, y + side_len], [x - triangle_height, y + side_len / 2], [x - triangle_height, y - side_len / 2], [x, y - side_len]];
		} else {
			points = [[x + side_len / 2, y - triangle_height], [x + side_len, y], [x + side_len / 2, y + triangle_height], [x - side_len / 2, y + triangle_height], [x - side_len, y], [x - side_len / 2, y - triangle_height]];
		}
		ctx.beginPath();
		ctx.lineWidth = lineWidth;
		ctx.strokeStyle = lineColor;
		ctx.fillStyle = fillColor;
		ctx.moveTo(points[5][0], points[5][1]);
		for (var i = 0; i < points.length; i++) {
			ctx.lineTo(points[i][0], points[i][1]);
		}
		ctx.fill();
		ctx.stroke();
		ctx.closePath();
	}


	function draw_initial_grid(grid_size) {

		let hex_side_len = canvas.height / 2 - 1;
		//draw_hexagon(canvas.width / 2, canvas.height / 2, hex_side_len, undefined, undefined, undefined, true);

		var hex_num_vertical = grid_size * 2 - 1;
		var blank_num_vertical = hex_num_vertical - 1;
		console.debug("hex_num_vertical: " + hex_num_vertical + ", blank_num_vertical: " + blank_num_vertical)
		let blank_ratio = 1/10;
		let blank_len = Math.floor(canvas.height * blank_ratio / (hex_num_vertical * blank_ratio + blank_num_vertical));

		let small_hex_len_vertical = canvas.height / (hex_num_vertical + blank_num_vertical * blank_ratio);//canvas.height / hex_num_vertical - blank_len / hex_num_vertical;
		let small_hex_len = small_hex_len_vertical / 2 / Math.cos(to_rad(30));

		console.debug(`blank_len: ${blank_len}, small_hex_len_vertical: ${small_hex_len_vertical}, small_hex_len: ${small_hex_len}`);

		/*for (var i = 0; i < hex_num_vertical; i++) {
			draw_hexagon(canvas.width / 2, i * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2, small_hex_len, 2);
		}*/


		/* the number of "columns" is also the number of tiles in the middle column */
		/* the column in the middle has grid_size * 2 - 1 tiles */
		column_num = grid_size * 2 - 1;
		let list = [];
		let id = 0;
		for (let i = 0; i < column_num; i++) {
			list.push([]);
			/* number of tiles in column is grid_size + i, valid up to the middle tho.*/
			let num_of_cells_in_column;
			let shift_x;
			if (i <= Math.floor(column_num / 2)) {
				num_of_cells_in_column = grid_size + i;
				shift_x = (column_num - num_of_cells_in_column) * (1.5 * small_hex_len + blank_len);//(column_num - num_of_cells_in_column) * (small_hex_len + blank_len);
			} else {
				num_of_cells_in_column = column_num - i + grid_size - 1;
				shift_x = -(column_num - num_of_cells_in_column) * (1.5 * small_hex_len + blank_len);
			}
			console.debug("num of cells: " + num_of_cells_in_column);

			/* each row going from the center, is shifted by half a hexagone per row */
			let shift_y = (column_num - num_of_cells_in_column) * (small_hex_len_vertical / 2 + blank_len / 2);//(column_num - num_of_cells_in_column) * small_hex_len_vertical / 2 + blank_len / 2;


			for (let j = 0; j < num_of_cells_in_column; j++) {
				draw_hexagon(canvas.width / 2 - shift_x, j * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2 + shift_y, small_hex_len, 2);
				list[i].push(new Cell(canvas.width / 2 - shift_x, j * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2 + shift_y, 'none', false, small_hex_len, id, i, j));
				id++;
			}
		}
		return list;
	}

	function draw_grid(grid) {
		console.debug('drawing grid');
		white_canvas();
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				if (grid[i][j].barred) {
					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2, undefined, '#000000');
					console.debug('filling');
				} else if (grid[i][j].selected) {
					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 3, '#47443c', '#baf6ff');
				} else if (grid[i][j].highlighted) {
					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 3, '#47443c', '#dcf8fc');
				} else {
					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2);
				}
				if (!grid[i][j].barred && grid[i][j].aspect != 'none') {
					console.debug('drawing image');
					img_size = grid[i][j].side_len * 1.2;
					//ctx.drawImage(grid[i][j].img, grid[i][j].x - img_size / 2, grid[i][j].y - img_size / 2, img_size, img_size);
					ctx.drawImage(image_cache[grid[i][j].aspect], grid[i][j].x - img_size / 2, grid[i][j].y - img_size / 2, img_size, img_size);
				}
			}
		}
		if (debugging) {
			draw_hex_ids(grid);
		}
	}

	function update_cell(grid, i, j) {
		draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2, '#ffffff', '#ffffff');
		if (grid[i][j].barred) {
			draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2, undefined, '#000000');
			console.debug('filling');
		} else if (grid[i][j].selected) {
			draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 3, '#47443c', '#baf6ff');
		} else if (grid[i][j].highlighted) {
			draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 3, '#47443c', '#dcf8fc');
		} else {
			draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2);
		}
		if (!grid[i][j].barred && grid[i][j].aspect != 'none') {
			console.debug('drawing image');
			img_size = grid[i][j].side_len * 1.2;
			//ctx.drawImage(grid[i][j].img, grid[i][j].x - img_size / 2, grid[i][j].y - img_size / 2, img_size, img_size);
			ctx.drawImage(image_cache[grid[i][j].aspect], grid[i][j].x - img_size / 2, grid[i][j].y - img_size / 2, img_size, img_size);
		}
	}

	function draw_debug_grid(grid) {
		console.log("===================");
		for (var i = 0; i < grid.length; i++) {
			var temp_str = "";
			for (var j = 0; j < grid[i].length; j++) {
				if (j < grid[i].length - 1) {
					temp_str += grid[i][j].id + ": " + grid[i][j].aspect + ", ";
				} else {
					temp_str += grid[i][j].id + ": " + grid[i][j].aspect;
				}
			}
			console.log(temp_str);
		}
		console.log("===================");
	}

	/* draws a circle in the middle of each cell/tile, for debugging purposes */
	function draw_hex_centers(grid) {
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				ctx.beginPath();
				ctx.arc(grid[i][j].x, grid[i][j].y, 5, 0, 2 * Math.PI);
				ctx.stroke();
				ctx.closePath();
			}
		}
	}

	function draw_hex_ids(grid) {
		ctx.font = "30px Arial";
		ctx.fillStyle = 'red';
		for (let i = 0; i < grid.length; i++) {
			for (let j = 0; j < grid[i].length; j++) {
				ctx.fillText(grid[i][j].id, grid[i][j].x, grid[i][j].y);
			}
		}
	}

	function assign_aspect() {
		if (selected_cell != undefined) {
			selected_cell.aspect = document.getElementById('aspect_selector').value;
			draw_grid(grid);
		}
	}

	function clear_grid(grid) {
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				grid[i][j].aspect = 'none';
				grid[i][j].barred = false;
			}
		}
	}

	function preset(num) {
		/* base */
		clear_grid(grid);
		if (num == 0) {
			grid = draw_initial_grid(3);
			current_state.grid = grid;
			grid[0][2].aspect = 'instrumentum';grid[2][0].aspect = 'permutatio';grid[4][2].aspect = 'metallum';
			draw_grid(grid);
		} else if (num == 1) {
			grid = draw_initial_grid(3);
			current_state.grid = grid;
			var barred_blacklist = [2, 5, 9, 13];
			for (var i = 0; i < grid.length; i++) {
				for (var j = 0; j < grid[i].length; j++) {
					var can_barr = true;
					for (var k = 0; k < barred_blacklist.length; k++) {
						if (barred_blacklist[k] == grid[i][j].id) {
							can_barr = false;
						}
					}
					if (can_barr) {
						grid[i][j].barred = true;
					}
				}
			}
			grid[0][2].aspect = 'aer';grid[3][1].aspect = 'lux';
			draw_grid(grid);
		} else if (num == 2) {
			grid = draw_initial_grid(4);
			current_state.grid = grid;grid[0][3].aspect = 'instrumentum';grid[3][0].aspect = 'arbor';grid[6][3].aspect = 'praecantatio';grid[0][0].barred = true;grid[4][2].barred = true;grid[5][3].barred = true;grid[6][1].barred = true;
			draw_grid(grid);
		} else if (num == 3) {
			grid = draw_initial_grid(4);
			current_state.grid = grid;
			grid[0][3].aspect = 'permutatio';grid[1][0].aspect = 'motus';grid[5][4].aspect = 'auram';grid[6][0].aspect = 'praecantatio';grid[3][4].barred = true;grid[3][6].barred = true;grid[4][4].barred = true;grid[6][3].barred = true;
			draw_grid(grid);
		} else if (num == 4) {
			grid = draw_initial_grid(5);
			current_state.grid = grid;
			grid[0][0].aspect = 'terra';grid[0][4].aspect = 'instrumentum';grid[4][0].aspect = 'aer';grid[4][8].aspect = 'praecantatio';grid[8][0].aspect = 'ordo';grid[8][4].aspect = 'arbor';grid[1][0].barred = true;grid[2][2].barred = true;grid[2][3].barred = true;grid[4][4].barred = true;grid[5][2].barred = true;grid[5][6].barred = true;grid[7][2].barred = true;grid[7][4].barred = true;
			draw_grid(grid);
		} else if (num == 5) {
			grid = draw_initial_grid(4);
			current_state.grid = grid;grid[0][3].aspect = 'instrumentum';grid[1][0].aspect = 'arbor';grid[4][0].aspect = 'gelum';grid[4][5].aspect = 'praecantatio';grid[6][2].aspect = 'aqua';grid[1][3].barred = true;grid[2][0].barred = true;grid[4][3].barred = true;
			draw_grid(grid);
		} else if (num == 6) {
			grid = draw_initial_grid(4);
			current_state.grid = grid;
			grid[0][3].aspect = 'instrumentum';grid[1][0].aspect = 'arbor';grid[4][0].aspect = 'ordo';grid[4][5].aspect = 'praecantatio';grid[6][2].aspect = 'terra';grid[0][1].barred = true;grid[3][4].barred = true;grid[4][4].barred = true;grid[5][4].barred = true;
			draw_grid(grid);
		} else if (num == 7) {
			grid = draw_initial_grid(5);
			current_state.grid = grid;
			grid[0][1].aspect = 'auram';
			grid[0][4].aspect = 'terra';
			grid[1][0].aspect = 'ignis';
			grid[3][7].aspect = 'permutatio';
			grid[4][0].aspect = 'gelum';
			grid[5][7].aspect = 'potentia';
			grid[7][0].aspect = 'perfodio';
			grid[8][1].aspect = 'perditio';
			grid[8][4].aspect = 'ordo';
			grid[1][3].barred = true;
			grid[3][0].barred = true;
			grid[4][3].barred = true;
			grid[5][0].barred = true;
			grid[5][6].barred = true;
			grid[7][4].barred = true;
			draw_grid(grid);
		} else {
			console.warn("Invalid preset!");
		}
		precalculate_cell_distances();
	}

	var aspect_table = {
		'aer':[],
		'alienis':['vacuos','tenebrae'],
		'aqua':[],
		'arbor':['aer','herba'],
		'auram':['aer','praecantatio'],
		'bestia':['motus','victus'],
		'cognitio':['ignis','spiritus'],
		'corpus':['bestia','mortuus'],
		'exanimis':['motus','mortuus'],
		'fabrico':['humanus','instrumentum'],
		'fames':['vacuos','victus'],
		'gelum':['ignis','perditio'],
		'herba':['terra','victus'],
		'humanus':['bestia','cognitio'],
		'ignis':[],
		'instrumentum':['ordo','humanus'],
		'iter':['terra','motus'],
		'limus':['aqua','victus'],
		'lucrum':['fames','humanus'],
		'lux':['aer','ignis'],
		'machina':['motus','instrumentum'],
		'messis':['herba','humanus'],
		'metallum':['terra','vitreus'],
		'meto':['instrumentum','messis'],
		'mortuus':['perditio','victus'],
		'motus':['aer','ordo'],
		'ordo':[],
		'pannus':['bestia','instrumentum'],
		'perditio':[],
		'perfodio':['terra','humanus'],
		'permutatio':['ordo','perditio'],
		'potentia':['ignis','ordo'],
		'praecantatio':['potentia','vacuos'],
		'sano':['ordo','victus'],
		'sensus':['aer','spiritus'],
		'spiritus':['victus','mortuus'],
		'telum':['ignis','instrumentum'],
		'tempestas':['aer','aqua'],
		'tenebrae':['lux','vacuos'],
		'terra':[],
		'tutamen':['terra','instrumentum'],
		'vacuos':['aer','perditio'],
		'venenum':['aqua','perditio'],
		'victus':['aqua','terra'],
		'vinculum':['perditio','motus'],
		'vitium':['perditio','praecantatio'],
		'vitreus':['ordo','terra'],
		'volatus':['aer','motus'],

		'desidia':['vinculum','spiritus'],
		'gula':['fames','vacuos'],
		'infernus':['ignis','praecantatio'],
		'invidia':['sensus','fames'],
		'ira':['telum','ignis'],
		'luxuria':['corpus','fames'],
		'superbia':['volatus','vacuos'],
		'tempus':['vacuos','ordo'],
		'electrum':['potentia','machina'],
		'magneto':['metallum','iter'],
		'nebrisum':['perfodio', 'lucrum'],
		'radio':['lux','potentia'],
		'strontio':['perditio','cognitio'],
		'terminus':['alienis','lucrum']
		/* Disabled in GT:NH, removed from GT++ too */
		/*,
		'sagrausten':['xenil','radio'],
		'slusium':['xenil','nebrisum'],
		'xablum':['xenil','slusium'],
		'xenil':['magneto','radio'],
		'zetralt':['xablum','auram']*/
	};

	/* Image cache (for debugging) */
	var images_loaded = false;
	var image_count = 0;
	for (var i = 0; i < keylen(aspect_table); i++) {
		let temp_img = new Image();
		temp_img.src = './hq_images_black_all/' + keyAtIndex(aspect_table, i) + '.png';
		image_cache[keyAtIndex(aspect_table, i)] = temp_img;
		temp_img.addEventListener("load", function () {
			image_count++;
			if (image_count == keylen(aspect_table)) {
				images_loaded = true;
				document.getElementById('loading').innerHTML = '';
				console.log("aspect images loaded");
			}
		});
	}

	/* Data structure for the grid: one array for each column, where each "cell" */
	/* is an object with properties like 'aspect', 'can be used', etc */
	/* Need functions for neighbor checks */

	var grid = draw_initial_grid(5);

	function resize_grid() {
		let input = document.getElementById('grid_size_input');
		white_canvas();
		//alert(input.value);
		grid = draw_initial_grid(parseInt(input.value));
		current_state.grid = grid;
	}

	function compounds(aspect) {
		return aspect_table[aspect];
	}

	/* for comparing tuples */
	function inArray(haystack, needle){
		for(item in haystack){
			if (haystack[item][0] == needle[0] && haystack[item][1] == needle[1]){
				return true;
			}
		}
		return false;
	}

	function in_normal_array(haystack, needle) {
		for (let i = 0; i < haystack.length; i++) {
			if (haystack[i] == needle) {
				return true;
			}
		}
		return false;
	}

	function array_contains_array(container, contained) {
		for (let i = 0; i < contained.length; i++) {
			let found = false;
			for (let j = 0; j < container.length; j++) {
				if (container[j] == contained[i]) {
					found = true;
				}
			}
			if (!found) {
				return false;
			}
		}
		return true;
	}

	function deepcopyOLD(object) {
		if (Array.isArray(object)) {
			var copy = [];
		} else if (typeof object === "object") {
			var copy = {};
		} else {
			var copy = [];
		}
		for (index in object) {
			if (Array.isArray(object[index]) || typeof object[index] === "object") {
				copy[index] = deepcopy(object[index]);
			} else {
				copy[index] = object[index];
			}
		}
		return copy;
	}

	/* source: http://voidcanvas.com/clone-an-object-in-vanilla-js-in-depth/ */
	function deepcopy(obj){
		if(obj===null || typeof obj !== "object"){
			return obj;
		} else if(Array.isArray(obj)){
			var clonedArr = [];
			obj.forEach(function(element){
				clonedArr.push(deepcopy(element))
			});
			return clonedArr;
	  } else{
		let clonedObj = {};
		for(var prop in obj){
			if(obj.hasOwnProperty(prop)){
				clonedObj[prop] = deepcopy(obj[prop]);
			}
		}
		return clonedObj;
	  }
	}

	function can_connect(aspect1, aspect2) {
		if (aspect_table[aspect1].includes(aspect2) || aspect_table[aspect2].includes(aspect1)) {
			return true;
		}
		return false;
	}

	function cell_exists(grid, x, y) {
		if (typeof grid[x] === 'undefined') {
			return false;
		}
		if (typeof grid[x][y] === 'undefined') {
			return false;
		}
		return true;
	}

	function paint_tiles(coord_list) {
		var real_coords = [];
		for (var i = 0; i < coord_list.length; i++) {
				real_coords.push([grid[coord_list[i][0]][coord_list[i][1]].x, grid[coord_list[i][0]][coord_list[i][1]].y]);
		}
		for (var i = 0; i < real_coords.length; i++) {
			draw_hexagon(real_coords[i][0], real_coords[i][1], grid[0][0].side_len, undefined, undefined, '#000000');
		}
	}

	function tile_neighbors(x, y, grid, all = false) {
		var left_coords = [[x, y - 1], [x + 1, y], [x + 1, y + 1], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var middle_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var right_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y + 1], [x - 1, y]];
		if (x == Math.floor(grid.length / 2)) {
			for (var i = 0; i < middle_coords.length; i++) {
				if (!cell_exists(grid, middle_coords[i][0], middle_coords[i][1]) || grid[middle_coords[i][0]][middle_coords[i][1]].aspect == 'none' || !((aspect_table[grid[x][y].aspect].includes(grid[middle_coords[i][0]][middle_coords[i][1]].aspect) || aspect_table[grid[middle_coords[i][0]][middle_coords[i][1]].aspect].includes(grid[x][y].aspect)) || all)) {
					middle_coords.splice(i, 1);
					i--;
				}
			}
			return middle_coords;
		} else if (x < Math.floor(grid.length / 2)) {
			for (var i = 0; i < left_coords.length; i++) {
				if (!cell_exists(grid, left_coords[i][0], left_coords[i][1]) || grid[left_coords[i][0]][left_coords[i][1]].aspect == 'none' || !((aspect_table[grid[x][y].aspect].includes(grid[left_coords[i][0]][left_coords[i][1]].aspect) || aspect_table[grid[left_coords[i][0]][left_coords[i][1]].aspect].includes(grid[x][y].aspect)) || all)) {
					left_coords.splice(i, 1);
					i--;
				}
			}
			return left_coords;
		}
		for (var i = 0; i < right_coords.length; i++) {
				if (!cell_exists(grid, right_coords[i][0], right_coords[i][1]) || grid[right_coords[i][0]][right_coords[i][1]].aspect == 'none' || !((aspect_table[grid[x][y].aspect].includes(grid[right_coords[i][0]][right_coords[i][1]].aspect) || aspect_table[grid[right_coords[i][0]][right_coords[i][1]].aspect].includes(grid[x][y].aspect) || all))) {
					right_coords.splice(i, 1);
					i--;
				}
			}
		return right_coords;
	}


	function tile_neighbors_wo_aspects(x, y, grid, ignore_barred = true) {
		var left_coords = [[x, y - 1], [x + 1, y], [x + 1, y + 1], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var middle_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var right_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y + 1], [x - 1, y]];
		if (x == Math.floor(grid.length / 2)) {
			for (var i = 0; i < middle_coords.length; i++) {
				if (!cell_exists(grid, middle_coords[i][0], middle_coords[i][1]) || (grid[middle_coords[i][0]][middle_coords[i][1]].barred && ignore_barred)) {
					middle_coords.splice(i, 1);
					i--;
				}
			}
			return middle_coords;
		} else if (x < Math.floor(grid.length / 2)) {
			for (var i = 0; i < left_coords.length; i++) {
				if (!cell_exists(grid, left_coords[i][0], left_coords[i][1]) || (grid[left_coords[i][0]][left_coords[i][1]].barred && ignore_barred)) {
					left_coords.splice(i, 1);
					i--;
				}
			}
			return left_coords;
		}
		for (var i = 0; i < right_coords.length; i++) {
				if (!cell_exists(grid, right_coords[i][0], right_coords[i][1]) || (grid[right_coords[i][0]][right_coords[i][1]].barred && ignore_barred)) {
					right_coords.splice(i, 1);
					i--;
				}
			}
		return right_coords;
	}

	/* This function only considers cell neighbors that can be connected */
	/* path takes blank cells into account */
	/* ignore_aspects doesn't take cells with aspects into account except the starting one */
	function neighbor_chain(x, y, grid, path = false, cell_list = null, ignore_aspects = false, current_path = []) {
		//console.log(`x: ${x}, y: ${y}, cell_list: ${cell_list}`);
		let first_time = false;
		if (cell_list == null) {
			cell_list = [];
			first_time = true;
		}
		if (((grid[x][y].aspect != 'none' || path) && (ignore_aspects ? (grid[x][y].aspect == 'none' || first_time) : true)) && !inArray(cell_list, [x, y]) && (current_path.length > 0 ? !current_path.includes(grid[x][y].id) : true)) {
			cell_list.push([x, y]);
			var neighbors;
			if (path) {
				neighbors = tile_neighbors_wo_aspects(x, y, grid);
			} else {
				neighbors = tile_neighbors(x, y, grid);
			}
			//console.log(`neighbors: ${neighbors}`);
			for (var i = 0; i < neighbors.length; i++) {
				//console.log(`i: ${i}, neighbor len: ${neighbors.length}`);
				neighbor_chain(neighbors[i][0], neighbors[i][1], grid, path, cell_list, ignore_aspects, current_path);
			}
		}
		return cell_list;
	}

	function check_continuity(grid) {
		var starting_cell;
		var aspect_cell_counter = 0;
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				if (grid[i][j].aspect != 'none') {
					if (starting_cell == undefined) {
						starting_cell = [i, j];
					}
					aspect_cell_counter ++;
				}
			}
		}
		if (neighbor_chain(starting_cell[0], starting_cell[1], grid).length != aspect_cell_counter) {
			return false;
		}
		return true;
	}

	function get_cell_by_id(id, grid) {
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				if (grid[i][j].id == id) {
					return grid[i][j];
				}
			}
		}
	}

	function id_in_blacklist(id, state) {
		for (var i = 0; i < keylen(state.impossible_closest_cells); i++) {
			if (keyAtIndex(state.impossible_closest_cells, i) == id) {
				return true;
			}
		}
		return false;
	}

	function aspect_blacklisted_at_id(aspect, id, state) {
		for (var i = 0; i < keylen(state.impossible_closest_cells); i++) {
			if (elemAtIndex(state.impossible_closest_cells, i) == aspect) {
				return true;
			}
		}
		return false;
	}

	/* Returns whether a cell is usable (aka all aspects haven't been blacklisted on it) */
	function impossible_id(id, state) {
		if (id_in_blacklist(id, state)) {
			if (keylen(aspect_table) == state.impossible_closest_cells[id].length) {
				return true;
			}
		}
		return false;
	}

	function last_used_path_cell(state, path = null) {
		if (!path) {
			path = state.current_path;
		}
		let neighbor_chain_of_path = neighbor_chain(get_cell_by_id(path[0], state.grid).array_x, get_cell_by_id(path[0], state.grid).array_y, state.grid);
		for (let i = 1; i < path.length; i++) {
			if (i == path.length - 1 && !neighbor_chain_of_path.includes(path[i])) {
				return path.length - 2;
			}
			if (get_cell_by_id(path[i], state.grid).aspect == 'none') {
				return i - 1;
			}
		}
		return path.length - 1;
	}

	function closest_cells(state) {
		/* basically take every cell and get all distances to all other cells */
		/* uses precalculated values */
		/* ignores cells that form a continuity */
		var current_closest_pair = [];
		for (var i = 0; i < state.grid.length; i++) {
			for (var j = 0; j < state.grid[i].length; j++) {
				/* check that the cell has an aspect and not in blacklist*/
				if (state.grid[i][j].aspect != 'none' && !impossible_id(state.grid[i][j].id, state)) {
					var current_neighbor_chain = neighbor_chain(i, j, state.grid);
					for (var k = 0; k < state.grid.length; k++) {
						/* check if the cell isn't already connected */
						var in_neighbor_chain = false;
						for (var l = 0; l < state.grid[k].length; l++) {
							/*if (state.grid[current_neighbor_chain[l][0]][current_neighbor_chain[l][1]].id == parseInt(keyAtIndex(distance_dict[state.grid[i][j].id], k))) {
								in_neighbor_chain = true;
							}*/
							if (inArray(current_neighbor_chain, [k , l])) {
								in_neighbor_chain = true;
							}

							if (state.current_path && !closest_neighbor_to_cell(state.grid[i][j].id, state.grid[k][l].id, state)) {
								continue;
							}
							if (state.current_path && !path_complete(state.current_path, state)) {
								if (grid[i][j].id != state.current_path[last_used_path_cell(state)] ) {
									continue;
								}
							}
							if (!in_neighbor_chain && state.grid[k][l].aspect != 'none' && !impossible_id(state.grid[k][l].id ,state)) {
								if (current_closest_pair.length == 0) {
									current_closest_pair = [state.grid[i][j].id, state.grid[k][l].id];
									if (state.current_path && sort_tuple(current_closest_pair, state.current_path)) {
										current_closest_pair = sort_tuple(current_closest_pair, state.current_path);
									}
								} else {
									var current_distance = get_distance(get_cell_by_id(current_closest_pair[0], state.grid).x, get_cell_by_id(current_closest_pair[0], state.grid).y, get_cell_by_id(current_closest_pair[1], state.grid).x, get_cell_by_id(current_closest_pair[1], state.grid).y);
									var potential_distance = get_distance(state.grid[i][j].x, state.grid[i][j].y, state.grid[k][l].x, state.grid[k][l].y);
									if (potential_distance < current_distance) {
										current_closest_pair = [state.grid[i][j].id, state.grid[k][l].id];
										if (state.current_path && sort_tuple(current_closest_pair, state.current_path)) {
											current_closest_pair = sort_tuple(current_closest_pair, state.current_path);
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (current_closest_pair.length == 0 && state.current_path) {
			return [state.current_path[0], state.current_path[state.current_path.length - 1]];
		}
		return current_closest_pair;
	}

	function precalculate_cell_distances() {
		console.log("precalculating distances: start");
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				for (var k = 0; k < grid.length; k++) {
					for (var l = 0; l < grid[k].length; l++) {
						if (!(i == k && j == l)) {
							if (!distance_dict[grid[i][j].id]) {
								distance_dict[grid[i][j].id] = {};
							}
							distance_dict[grid[i][j].id][grid[k][l].id] = get_distance(grid[i][j].x, grid[i][j].y, grid[k][l].x, grid[k][l].y);
						}
					}
				}
			}
		}
		console.log("precalculating distances: done");
	}

	function closest_neighbor_to_cell(id1, id2, state, path = [], custom_blacklist = [], finding_path = false, current_path = []) {
		var cell1 = get_cell_by_id(id1, state.grid);
		var cell2 = get_cell_by_id(id2, state.grid);
		var temp_neighbors = tile_neighbors_wo_aspects(cell1.array_x, cell1.array_y, state.grid);
		var temp_closest_neighbor = null;
		var temp_closest_distance = null;
		for (var i = 0; i < temp_neighbors.length; i++) {
			let target = state.grid[temp_neighbors[i][0]][temp_neighbors[i][1]];
			if (target.aspect == 'none' && !target.barred && (finding_path ? in_same_space(cell2.id, target.id, state.grid, true, current_path) : true) && ((state.current_path && state.current_path.length > 0) ? target.id == state.current_path[last_used_path_cell(state, state.current_path) + 1] : true)) {
				if (temp_closest_neighbor == null && !custom_blacklist.includes(target.id) && (path.length > 0 == path.includes(target.id)) && (state.current_path_forbidden_child ? state.current_path_forbidden_child[id1] != target.id : true) && (finding_path ? !current_path.includes(target.id) : true)) {
					temp_closest_neighbor = target.id;
					temp_closest_distance = distance_dict[id2][target.id];//distance_dict[target.id][id2];
				} else if ((distance_dict[id2][target.id] < temp_closest_distance) && !custom_blacklist.includes(target.id) && (path.length > 0 == path.includes(target.id)) && (state.current_path_forbidden_child ? state.current_path_forbidden_child[id1] != target.id : true) && (finding_path ? !current_path.includes(target.id) : true)) {
					temp_closest_neighbor = target.id;
					temp_closest_distance = distance_dict[id2][target.id];
				}
			}
		}
		return temp_closest_neighbor;
	}

	function complexity(aspect, counter=null) {
		if (counter == null) {
			counter = 0;
		}
		counter++;
		if (!aspect) {
			return 0;
		}
		if (aspect_table[aspect].length == 1) {
			return 0;
		} else {
			counter += Math.max(complexity(aspect_table[aspect][0]), complexity(aspect_table[aspect][1]));
		}
		return counter;
	}

	/* Returns true if an aspect contains another */
	function contains(container, contained) {
		if (aspect_table[container].length == 1) {
			if (aspect_table[container][0] == contained) {
				return 0;
			}
		} else {
			if (aspect_table[container][0] == contained) {
				return 0;
			}
			if (aspect_table[container][1] == contained) {
				return 1;
			}
		}
		return -1;
	}

	function can_use_aspect(id, aspect, state) {
		if (state.impossible_closest_cells[id]) {
			for (var i = 0; i < state.impossible_closest_cells[id].length; i++) {
				if (state.impossible_closest_cells[id][i] == aspect) {
					return false;
				}
			}
		}
		return true;
	}

	function best_aspect(starting_cell_id, target_cell_id, neighbor_cell_id, state) {
		var starting_cell = get_cell_by_id(starting_cell_id, state.grid);
		var target_cell = get_cell_by_id(target_cell_id, state.grid);
		var neighbor_cell = get_cell_by_id(neighbor_cell_id, state.grid);

		var least_complex_aspect = null;
		var current_complexity = null;

		/* small complexity < being linked to target cell */
		if (aspect_table[starting_cell.aspect].length == 0) {
			/* primal aspect, must choose compound that includes it */
			/* trying to have smallest complexity */
			/* and then search again to see i we can get something directly related */
			for (var i = 0; i < keylen(aspect_table); i++) {
				if (can_use_aspect(neighbor_cell_id, keyAtIndex(aspect_table, i), state) && least_complex_aspect == null) {
					if (contains(keyAtIndex(aspect_table, i), starting_cell.aspect) > -1) {
						least_complex_aspect = keyAtIndex(aspect_table, i); //aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						current_complexity = complexity(least_complex_aspect);
					}
				} else {
					if (can_use_aspect(neighbor_cell_id, keyAtIndex(aspect_table, i), state) && contains(keyAtIndex(aspect_table, i), starting_cell.aspect) > -1) {
						var temp_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						if (current_complexity > complexity(temp_aspect)) {
							least_complex_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
							current_complexity = complexity(least_complex_aspect);
						}
					}
				}
			}
			/* trying to match a bit the target aspect */
			if (temp_aspect) {
				for (var i = 0; i < keylen(aspect_table); i++) {
					if (can_use_aspect(neighbor_cell_id, keyAtIndex(aspect_table, i), state) && contains(keyAtIndex(aspect_table, i), starting_cell.aspect) > -1) {
						if ((current_complexity == complexity(temp_aspect) || Math.abs(current_complexity - complexity(temp_aspect)) == 1) && (contains(temp_aspect, target_cell.aspect) || contains(target_cell.aspect, temp_aspect))) {
							least_complex_aspect = temp_aspect;
							current_complexity = complexity(temp_aspect);
						}
					}
				}
			}
		} else if (aspect_table[starting_cell.aspect].length == 2) {
			/* compound aspect */
			for (var i = 0; i < keylen(aspect_table); i++) {
				if (least_complex_aspect == null) {
					if (can_use_aspect(neighbor_cell_id, keyAtIndex(aspect_table, i), state) && can_connect(starting_cell.aspect, keyAtIndex(aspect_table, i))) {
						least_complex_aspect = keyAtIndex(aspect_table, i); //aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						current_complexity = complexity(least_complex_aspect);
					}
				} else {
					if (can_use_aspect(neighbor_cell_id, keyAtIndex(aspect_table, i), state) && can_connect(starting_cell.aspect, keyAtIndex(aspect_table, i))) {
						var temp_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						if (current_complexity > complexity(temp_aspect)) {
							least_complex_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
							current_complexity = complexity(least_complex_aspect);
						}
					}
				}
			}
			if (temp_aspect) {
				for (var i = 0; i < keylen(aspect_table); i++) {
					if (can_use_aspect(neighbor_cell_id, keyAtIndex(aspect_table, i), state) && contains(starting_cell.aspect, keyAtIndex(aspect_table, i)) > -1) {
						if ((current_complexity == complexity(temp_aspect) || Math.abs(current_complexity - complexity(temp_aspect)) == 1) && (contains(temp_aspect, target_cell.aspect) || contains(target_cell.aspect, temp_aspect))) {
							least_complex_aspect = temp_aspect;
							current_complexity = complexity(temp_aspect);
						}
					}
				}
			}
		}
		return least_complex_aspect;
	}

	/* Blacklists given aspect for given cell and state */
	function blacklist_aspect(id, aspect, state) {
		if (!state.impossible_closest_cells[id]) {
			state.impossible_closest_cells[id] = [];
		}
		if (state.impossible_aspects_for_current_path == null) {
			state.impossible_aspects_for_current_path = {};
		}
		if (!state.impossible_aspects_for_current_path.hasOwnProperty(id)) {
			state.impossible_aspects_for_current_path[id] = [];
		}
		state.impossible_closest_cells[id].push(aspect);
		state.impossible_aspects_for_current_path[id].push(aspect);
		state.impossible_aspects_for_current_path[id] = remove_dupes(state.impossible_aspects_for_current_path[id]);
	}

	/* Checks if two cells are not separated by barred cells, optionnaly separated by aspects */
	function in_same_space(id1, id2, grid, aspects = false, current_path = []) {
		let cell1 = get_cell_by_id(id1, grid);
		let cell2 = get_cell_by_id(id2, grid);
		let temp_chain = neighbor_chain(cell1.array_x, cell1.array_y, grid, true, null, aspects, current_path);
		if (inArray(temp_chain, [cell2.array_x, cell2.array_y])) {
			return true;
		}
		return false;
	}

	function arrays_equal(a, b) {
		if (a.length != b.length) {
			return false;
		}
		for (let i = 0; i < a.length; i++) {
			if (a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}

	function occurence_in_array(array, value) {
		let counter = 0;
		for (let i = 0; i < array.length; i++) {
			if (array[i] == value) {
				counter++;
			}
		}
		return counter;
	}

	function sort_tuple(tuple, pattern_array) {
		if (tuple.length != 2 || pattern_array.length < 2) {
			return null;
		}
		if (!in_normal_array(pattern_array, tuple[0]) || !in_normal_array(pattern_array, tuple[1])) {
			return null;
		}
		if (pattern_array.indexOf(tuple[0]) < pattern_array.indexOf(tuple[1])) {
			return tuple;
		}
		return [tuple[1], tuple[0]];
	}

	function arrays_same_content(a, b) {
		if (a.length != b.length) {
			return false;
		}
		for (let i = 0; i < a.length; i++) {
			if (occurence_in_array(a, a[i]) != occurence_in_array(b, a[i])) {
				return false;
			}
		}
		return true;
	}

	function already_blacklisted_cells_from_path(blacklisted_path, blacklisted_cells) {
		let counter = 0;
		for (let i = 0; i < blacklisted_path.length; i++) {
			if (blacklisted_cells[i] && blacklisted_cells[i] == blacklisted_path[i]) {
				counter++;
			}
		}
		return counter;
	}

	/* Finds shortest path from one cell to another considering blacklisted paths */
	function find_path(id1, id2, state) {
		//let res = [];
		/*state.blacklisted_paths.push([0, 1, 2, 3]);
		state.blacklisted_paths.push([0, 1, 6, 2, 3]);
		state.blacklisted_paths.push([0, 1, 6, 7, 3]);*/

		let cell1 = get_cell_by_id(id1, state.grid);
		let cell2 = get_cell_by_id(id2, state.grid);
		let found = false;
		let depth_limit = 100000;
		let current_depht = 0;
		let path_return_from_bad_state = false;
		let path_state_history = [];
		class Path_state {
			constructor(starting_cell_id) {
				//'parent':'blacklisted child'
				this.blacklist_dict = {};
				this.current_path = [starting_cell_id];
			}
		}
		let original_path = new Path_state(id1);
		let current_path_state = new Path_state(id1);
		while(!found) {
			current_depht++;
			if (current_depht == depth_limit) {
				return null;
			}
			if (!path_return_from_bad_state) {
				let cell_to_append = null;
				if (current_path_state.blacklist_dict.hasOwnProperty(current_path_state.current_path[current_path_state.current_path.length - 1])) {
					cell_to_append = get_cell_by_id(closest_neighbor_to_cell(current_path_state.current_path[current_path_state.current_path.length - 1], id2, state, [], current_path_state.blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 1]].concat(current_path_state.current_path), true, current_path_state.current_path), state.grid);
				} else {
					cell_to_append = get_cell_by_id(closest_neighbor_to_cell(current_path_state.current_path[current_path_state.current_path.length - 1], id2, state, [], [], true, current_path_state.current_path), state.grid);
				}
				if (cell_to_append) {
					current_path_state.current_path.push(cell_to_append.id);
					path_state_history.push(deepcopy(current_path_state));

					let grid_copy = deepcopy(state.grid);
					for (let i = 0; i < grid_copy.length; i++) {
						for (let j = 0; j < grid_copy[i].length; j++) {
							if (!current_path_state.current_path.includes(grid_copy[i][j].id) && grid_copy[i][j].id != id2) {
								grid_copy[i][j].barred = true;
							}
						}
					}
					if (inArray(neighbor_chain(cell1.array_x, cell1.array_y, grid_copy, true), [cell2.array_x, cell2.array_y])) {
						current_path_state.current_path.push(id2);
						let same = false;
						for (let i = 0; i < state.blacklisted_paths.length; i++) {
							if (arrays_equal(state.blacklisted_paths[i], current_path_state.current_path)) {
								same = true;
								path_return_from_bad_state = true;
								break;
							}
						}
						if (!same) {
							return current_path_state.current_path;
						}
					}
				} else {
					path_return_from_bad_state = true;
				}
			} else {
				// path_state_history.pop();
				// if (path_state_history.length == 0) {
				// 	path_state_history.push(deepcopy(original_path));
				// }
				//if (path_state_history[path_state_history.length - 1].blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 3]] == undefined) {
				//	path_state_history[path_state_history.length - 1].blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 3]] = [];
				//}

				if (path_state_history[path_state_history.length - 1].blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 2]] == undefined) {
					path_state_history[path_state_history.length - 1].blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 2]] = [];
				}
				path_state_history[path_state_history.length - 1].blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 2]].push(current_path_state.current_path[current_path_state.current_path.length - 1]);
				

				//path_state_history[path_state_history.length - 1].blacklist_dict[current_path_state.current_path[current_path_state.current_path.length - 3]].push(current_path_state.current_path[current_path_state.current_path.length - 2]);



				current_path_state = deepcopy(path_state_history[path_state_history.length - 1]);
				path_state_history.pop();
				if (path_state_history.length == 0) {
					path_state_history.push(deepcopy(original_path));
				}
				path_return_from_bad_state = false;
			}
		}
	}

	/* Removes dupes form an array */
	function remove_dupes(array) {
		let res = [];
		for (var i = 0; i < array.length; i++) {
			if (!res.includes(array[i])) {
				res.push(array[i]);
			}
		}
		return res;
	}

	/* Returns true if every aspect has been tried for the path */
	function every_aspect_tried_for_path(path, state) {
		let grid = state.grid;
		let possible_aspects = [[get_cell_by_id(path[0], grid).aspect]];
		let possible_aspects_dict = {};
		for (let i = 1; i < path.length - 1; i++) {
			possible_aspects.push([]);
			for (let j = 0; j < keylen(aspect_table); j++) {
				for (let k = 0; k < possible_aspects[i - 1].length; k++) {
					if (can_connect(possible_aspects[i - 1][k], keyAtIndex(aspect_table, j))) {
						possible_aspects[i].push(keyAtIndex(aspect_table, j));
					}
				}
			}
			possible_aspects[i] = remove_dupes(possible_aspects[i]);
			possible_aspects_dict[path[i]] = possible_aspects[i];
		}
		
		//
		// debug ///state.impossible_closest_cells = possible_aspects_dict;
		//

		//return possible_aspects_dict;
		if (keylen(state.impossible_closest_cells) == 0) {
			return false;
		}
		for (let i = 0; i < keylen(state.impossible_closest_cells); i++) {
			if (!possible_aspects_dict[keyAtIndex(state.impossible_closest_cells, i)]) {
				return false;
			}
			if (state.impossible_closest_cells[keyAtIndex(state.impossible_closest_cells, i)].length != possible_aspects_dict[keyAtIndex(state.impossible_closest_cells, i)].length) {
				return false;
			}
		}
		return true;
	}

	function path_complete(path, state) {
		let first_path_cell = get_cell_by_id(path[0], state.grid);
		let neighbors = neighbor_chain(first_path_cell.array_x, first_path_cell.array_y, state.grid);
		for (let i = 0; i < neighbors.length; i++) {
			neighbors[i] = state.grid[neighbors[i][0]][neighbors[i][1]].id;
		}
		//if (arrays_same_content(path, neighbors)) {
		if (array_contains_array(neighbors, path)) {
			return true;
		}
		return false;
	}

	function remove_excess_aspects(state) {
		for (let i = 0; i < state.current_path.length - 2; i++) {
			let cell1 = get_cell_by_id(state.current_path[i], state.grid);
			let cell2 = get_cell_by_id(state.current_path[i + 1], state.grid);
			let cell3 = get_cell_by_id(state.current_path[i + 2], state.grid);
			if (cell1.aspect == 'none' || cell2.aspect == 'none' || cell3.aspect == 'none') {
				continue;
			}
			let cell1_neighbors = tile_neighbors(cell1.array_x, cell1.array_y, state.grid, true);
			let are_neighbors = false;
			for (let j = 0; j < cell1_neighbors.length; j++) {
				if (cell3.id == state.grid[cell1_neighbors[j][0]][cell1_neighbors[j][1]].id) {
					are_neighbors = true;
				}
			}
			if (are_neighbors && can_connect(cell1.aspect, cell3.aspect)) {
				cell3.aspect = 'none';
				if (debugging) {
					draw_grid(state.grid);
				}
			}
		}
		for (let i = 1; i < state.current_path.length - 1; i++) {
			let cell1 = get_cell_by_id(state.current_path[i], state.grid);
			if (cell1.aspect == 'none') {
				continue;
			}
			let cell_neighbors = tile_neighbors(cell1.array_x, cell1.array_y, state.grid, true);
			let connected_count = 0;
			for (let j = 0; j < cell_neighbors.length; j++) {
				if (can_connect(cell1.aspect, state.grid[cell_neighbors[j][0]][cell_neighbors[j][1]].aspect)) {
					connected_count ++;
				}
			}
			if (connected_count == 1) {
					cell1.aspect = 'none';
					if (debugging) {
						draw_grid(state.grid);
					}
				}
		}
	}

	function main_loop(){
		if (depth == 22) {
			console.log("debug");
		}
		if (depth == 198) {
			console.log("debug");
		}
		console.log(`entering depth ${depth}`);
		depth++;
		if (debugging) {
			draw_grid(current_state.grid);
		}
		if (check_continuity(current_state.grid)) {
			solved = true;
			console.log("==============\nS O L V E D\n==============");
			return;
		}
		if (!returning_from_bad_state) {
			console.log(`Not returning from bad state`)

			var temp_closest_cells = closest_cells(current_state);
			if (temp_closest_cells.length > 0) {
				if (current_state.current_path && path_complete(current_state.current_path, current_state)) {
					remove_excess_aspects(current_state);
					current_state.current_path = null;
				} else {
					if (!current_state.current_path) {
						current_path = find_path(temp_closest_cells[0], temp_closest_cells[1], current_state);
						current_state.current_path = deepcopy(current_path);
					}
					var first_cell = get_cell_by_id(temp_closest_cells[0], current_state.grid);
					var second_cell = get_cell_by_id(temp_closest_cells[1], current_state.grid);
					if (current_state.current_path) {
						current_state.last_move = [first_cell.id, second_cell.id];
						var closest_neighbor = get_cell_by_id(closest_neighbor_to_cell(first_cell.id, second_cell.id, current_state, current_state.current_path), current_state.grid);
						if (closest_neighbor) {
							var temp_best_aspect = best_aspect(first_cell.id, second_cell.id, closest_neighbor.id, current_state);
							if (temp_best_aspect) {
								closest_neighbor.aspect = temp_best_aspect;
								current_state.last_cell = closest_neighbor.id;
								grid = current_state.grid;
								state_history.push(deepcopy(current_state));
							} else {
								returning_from_bad_state = true;
								if (first_cell.id == current_state.current_path[0]) {
									current_state.bad_state_reason = 'invalid_path';
								} else {
									current_state.bad_state_reason = 'no_aspect';
								}
							}
						} else {
							returning_from_bad_state = true;
							current_state.bad_state_reason = 'no_neighbor';
						}
					} else {
						returning_from_bad_state = true;
						current_state.bad_state_reason = 'no_path';
					}
				}
			} else {
				returning_from_bad_state = true;
				current_state.bad_state_reason = 'no_closest_cells';
			}
		} else {
			console.log(`Returning from bad state`)

			if (current_state.bad_state_reason == 'no_aspect') {
				//Means that all possible aspects for a cell in a path are blacklisted
				//Fix: blacklist last added aspect and go back
				
				state_history.pop();
				if (state_history.length <= 0) {
					current_state.current_path = null;
					state_history.push(deepcopy(original_state));
				}
				let cell_to_blacklist = get_cell_by_id(current_state.last_cell, current_state.grid);
				blacklist_aspect(cell_to_blacklist.id, cell_to_blacklist.aspect, state_history[state_history.length - 1]);
				current_state = deepcopy(state_history[state_history.length - 1]);
				
			} else if (current_state.bad_state_reason == 'no_neighbor') {
				//Usually means that the path has been filled and it's wrong
				//Fix: blacklist last added aspect and go back

				state_history.pop();
				if (state_history.length <= 0) {
					current_state.current_path = null;
					state_history.push(deepcopy(original_state));
				}
				let cell_to_blacklist = get_cell_by_id(current_state.last_cell, current_state.grid);
				blacklist_aspect(cell_to_blacklist.id, cell_to_blacklist.aspect, state_history[state_history.length - 1]);
				current_state = deepcopy(state_history[state_history.length - 1]);
				
			} else if (current_state.bad_state_reason == 'no_path') {
				
			} else if (current_state.bad_state_reason == 'no_closest_cells') {
				//sure, that's pretty bad
			} else if (current_state.bad_state_reason == 'invalid_path') {
				current_state.blacklisted_paths.push(current_state.current_path);
				state_history[state_history.length - 1].blacklisted_paths.push(current_state.current_path);
				current_state.current_path = null;
				current_state.impossible_aspects_for_current_path = {};
				current_state.impossible_closest_cells = {};
			}
			returning_from_bad_state = false;
		}
	}

	var current_state = new State(grid);
	var depth = 0;
	var state_history = [];
	var original_grid;
	var original_state;
	var returning_from_bad_state = false;
	var last_touched_cells = null;
	var chosen_cell = null;
	var considered_cells = null;
	var solved = false;
	var max_depth = 10000;
	var current_path = null;

	function solve() {
		precalculate_cell_distances();
		original_grid = deepcopy(grid);
		original_state = new State(original_grid);
		for (var i = 0; i < grid.length; i++) {
			for (var j = 0; j < grid[i].length; j++) {
				if (grid[i][j].aspect != 'none') {
					grid[i][j].base = true;
				}
			}
		}
		while(!solved && depth < max_depth) {
			main_loop();
		}
		draw_grid(grid);
	}

	/* 1. Find path between two closest aspects */
	/* 2. Try to build a path between them. Count that path as one move */
	/*    The path uses itself a backtracing algorithm */
	/* 3. If all possible combinations for a path fail and all paths for current aspects */
	/*    fail, redo the previous path differently */

</script>
</html>