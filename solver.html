<!DOCTYPE html>
<html>
<head>
	<title>GTNH TC Research Solver</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<style>
		#canvas {
			/* border: solid 1px; */
		}
		body {
			background-color: #232327;
		}
	</style>
</head>
<body>
	<canvas id='canvas' onclick="handle_click(event)"></canvas>
	<br>
	<button onclick='mouse_selection_mode()'>Selection mode (for choosing aspects)</button>
	<br>
	<button onclick='mouse_barring_mode()'>Barring mode (bar the cells that aren't available)</button>
	<br>
	<select id="aspect_selector" onchange="assign_aspect()">
		<option value="none">Aspect - none</option>
		<option value="aer">Aer</option>
		<option value="alienis">Alienis</option>
		<option value="aqua">Aqua</option>
		<option value="arbor">Arbor</option>
		<option value="auram">Auram</option>
		<option value="bestia">Bestia</option>
		<option value="cognitio">Cognitio</option>
		<option value="corpus">Corpus</option>
		<option value="exanimis">Exanimis</option>
		<option value="fabrico">Fabrico</option>
		<option value="fames">Fames</option>
		<option value="gelum">Gelum</option>
		<option value="herba">Herba</option>
		<option value="humanus">Humanus</option>
		<option value="ignis">Ignis</option>
		<option value="instrumentum">Instrumentum</option>
		<option value="iter">Iter</option>
		<option value="limus">Limus</option>
		<option value="lucrum">Lucrum</option>
		<option value="lux">Lux</option>
		<option value="machina">Machina</option>
		<option value="messis">Messis</option>
		<option value="metallum">Metallum</option>
		<option value="meto">Meto</option>
		<option value="mortuus">Mortuus</option>
		<option value="motus">Motus</option>
		<option value="ordo">Ordo</option>
		<option value="pannus">Pannus</option>
		<option value="perditio">Perditio</option>
		<option value="perfodio">Perfodio</option>
		<option value="permutatio">Permutatio</option>
		<option value="potentia">Potentia</option>
		<option value="praecantatio">Praecantatio</option>
		<option value="sano">Sano</option>
		<option value="sensus">Sensus</option>
		<option value="spiritus">Spiritus</option>
		<option value="telum">Telum</option>
		<option value="tempestas">Tempestas</option>
		<option value="tenebrae">Tenebrae</option>
		<option value="terra">Terra</option>
		<option value="tutamen">Tutamen</option>
		<option value="vacuos">Vacuos</option>
		<option value="venenum">Venenum</option>
		<option value="victus">Victus</option>
		<option value="vinculum">Vinculum</option>
		<option value="vitium">Vitium</option>
		<option value="vitreus">Vitreus</option>
		<option value="volatus">Volatus</option>
	</select>
	<br>
	<button onclick="solve()">Solve</button>
	<br><br>
	<button onclick="preset()">preset (debug)</button>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js"></script>
<script>

	/* detect click outside of canvas */
	document.addEventListener('click', function(event) {
	  	var isClickInside = document.getElementById('canvas').contains(event.target) || document.getElementById('aspect_selector').contains(event.target);
	  	if (!isClickInside && selected_cell != undefined) {
	    	selected_cell.selected = false;
	    	selected_cell = undefined;
	    	draw_grid(grid);
	  	}
	});

	var image_cache = {};

	/* util functions, going into separate file later */

	/* degrees to radians */
	function to_rad(deg) {
		return deg * Math.PI / 180;
	}

	/* distance between two points */
	function get_distance(x1, y1, x2, y2) {
		return Math.sqrt(Math.abs(x1 - x2) * Math.abs(x1 - x2) + Math.abs(y1 - y2) * Math.abs(y1 - y2));
	}

	/* object handling */
	function keylen(obj) {
		return Object.keys(obj).length;
	}

	function keyAtIndex(obj, index) {
		return Object.keys(obj)[index];
	}

	function elemAtIndex(obj, index) {
		return obj[Object.keys(obj)[index]];
	}

	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');

	function white_canvas() {
		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	class Cell {
		constructor(x, y, aspect, barred, side_len, id, array_x, array_y) {
		    this.x = x;
		    this.y = y;
		    this.aspect = aspect;
		    this.barred = barred;
		    this.side_len = side_len;
		    this.selected = false;
		    this.img;
		    this.base = false;
		    this.id = id;
		    //this.distance_dict = {};
		    this.array_x = array_x;
		    this.array_y = array_y;
	  	}
	}

	var distance_dict = {};

	class State {
		constructor(grid) {
			this.grid = grid;
			this.impossible_closest_cells = [];
			this.last_move = null;
			this.last_cell = null;
		}
	}

	var mouse_mode = 'selecting';
	var selected_cell;

	function mouse_selection_mode() {
		mouse_mode = 'selecting';
	}

	function mouse_barring_mode() {
		mouse_mode = 'barring';
		if (selected_cell != undefined) {
			selected_cell.selected = false;
			selected_cell = undefined;
		}
	}

	function handle_click(event) {
	  	var mouse_x = event.clientX;
	  	var mouse_y = event.clientY;
	  	var coords = "X coords: " + mouse_x + ", Y coords: " + mouse_y;
  		console.debug(coords);
  		var found = false;
  		/* loop through all cells in grid and find which one is nearest to the click */
  		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				//console.debug(grid[i][j].y);
  				console.debug(`acceptable distance: ${grid[i][j].side_len}`);
  				distance = Math.sqrt(Math.pow(Math.abs(grid[i][j].x - mouse_x), 2) + Math.pow(Math.abs(grid[i][j].y - mouse_y), 2));
  				if (distance <= grid[i][j].side_len) {
  					found = true;
  					console.debug(`found at ${parseFloat(grid[i][j].x).toFixed(2)}, ${parseFloat(grid[i][j].y).toFixed(2)} at distance ${distance}`);
  					if (mouse_mode == 'barring') {
  						if (grid[i][j].barred) {
	  						grid[i][j].barred = false;
	  					} else {
	  						grid[i][j].selected = false;
	  						grid[i][j].aspect = 'none';
	  						grid[i][j].barred = true;
	  					}
  					}
  					if (mouse_mode == 'selecting') {
  						if (grid[i][j].selected) {
	  						grid[i][j].selected = false;
	  					} else if (!grid[i][j].barred) {
	  						grid[i][j].selected = true;
	  						if (selected_cell != undefined && selected_cell != grid[i][j]) {
	  							selected_cell.selected = false;
	  							selected_cell = undefined;
	  						}
	  						selected_cell = grid[i][j];
	  					}
  					}
  					break;
  				}
  			}
  		}
  		if (!found && selected_cell != undefined) {
  			selected_cell.selected = false;
  			selected_cell = undefined;
  		}
  		if (selected_cell != undefined && selected_cell.selected) {
  			document.getElementById('aspect_selector').value = selected_cell.aspect;
  		}
  		draw_grid(grid);
	}

	/* Resizing the canvas 31.25 percent of screen width (400 px if the screen is 1280 px wide) */
	var screen_percentage = 31.25;
	canvas.height = screen.width / 100 * screen_percentage;
	canvas.width = screen.width / 100 * screen_percentage;
	
	/* drawing default size hex grid. Regular hexagon, "size 4" */
	/* the whole grid should always take the maximum space */
	/* a place in the grid should be selected on the canvas and then the aspect that is there must be a html panel below where one can search for the aspect and click to place it */
	var grid_size = 4;

	/* Drawing hexagon at coords */
	function draw_hexagon(x, y, side_len, lineWidth = 1, lineColor = '#000000', fillColor = '#FFFFFF', pointing_up = false) {
		console.debug("side_len: " + side_len)
		side_len -= Math.ceil(lineWidth / 2) + 1;
		var triangle_height = Math.sqrt(Math.pow(side_len, 2) - Math.pow(side_len / 2, 2));
		var points;
		if (pointing_up) {
			points = [[x + triangle_height, y - side_len / 2], [x + triangle_height, y + side_len / 2], [x, y + side_len], [x - triangle_height, y + side_len / 2], [x - triangle_height, y - side_len / 2], [x, y - side_len]];
		} else {
			points = [[x + side_len / 2, y - triangle_height], [x + side_len, y], [x + side_len / 2, y + triangle_height], [x - side_len / 2, y + triangle_height], [x - side_len, y], [x - side_len / 2, y - triangle_height]];
		}
		ctx.beginPath();
		ctx.lineWidth = lineWidth;
		ctx.strokeStyle = lineColor;
		ctx.fillStyle = fillColor;
		ctx.moveTo(points[5][0], points[5][1]);
		for (var i = 0; i < points.length; i++) {
			ctx.lineTo(points[i][0], points[i][1]);
		}
		ctx.fill();
		ctx.stroke();
		ctx.closePath();
	}


	function draw_initial_grid(grid_size) {

		var hex_side_len = canvas.height / 2 - 1;
		//draw_hexagon(canvas.width / 2, canvas.height / 2, hex_side_len, undefined, undefined, undefined, true);

		var hex_num_vertical = grid_size * 2 - 1;
		var blank_num_vertical = hex_num_vertical - 1;
		console.debug("hex_num_vertical: " + hex_num_vertical + ", blank_num_vertical: " + blank_num_vertical)
		var blank_ratio = 1/10;
		var blank_len = Math.floor(canvas.height * blank_ratio / (hex_num_vertical * blank_ratio + blank_num_vertical));

		var small_hex_len_vertical = canvas.height / (hex_num_vertical + blank_num_vertical * blank_ratio);//canvas.height / hex_num_vertical - blank_len / hex_num_vertical;
		var small_hex_len = small_hex_len_vertical / 2 / Math.cos(to_rad(30));

		console.debug(`blank_len: ${blank_len}, small_hex_len_vertical: ${small_hex_len_vertical}, small_hex_len: ${small_hex_len}`);

		/*for (var i = 0; i < hex_num_vertical; i++) {
			draw_hexagon(canvas.width / 2, i * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2, small_hex_len, 2);
		}*/


		/* the number of "columns" is also the number of tiles in the middle column */
		/* the column in the middle has grid_size * 2 - 1 tiles */
		column_num = grid_size * 2 - 1;
		var list = [];
		var id = 0;
		for (var i = 0; i < column_num; i++) {
			list.push([]);
			/* number of tiles in column is grid_size + i, valid up to the middle tho.*/
			var num_of_cells_in_column;
			var shift_x;
			if (i <= Math.floor(column_num / 2)) {
				num_of_cells_in_column = grid_size + i;
				shift_x = (column_num - num_of_cells_in_column) * (1.5 * small_hex_len + blank_len);//(column_num - num_of_cells_in_column) * (small_hex_len + blank_len);
			} else {
				num_of_cells_in_column = column_num - i + grid_size - 1;
				shift_x = -(column_num - num_of_cells_in_column) * (1.5 * small_hex_len + blank_len);
			}
			console.debug("num of cells: " + num_of_cells_in_column);

			/* each row going from the center, is shifted by half a hexagone per row */
			var shift_y = (column_num - num_of_cells_in_column) * (small_hex_len_vertical / 2 + blank_len / 2);//(column_num - num_of_cells_in_column) * small_hex_len_vertical / 2 + blank_len / 2;


			for (var j = 0; j < num_of_cells_in_column; j++) {
				draw_hexagon(canvas.width / 2 - shift_x, j * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2 + shift_y, small_hex_len, 2);
				list[i].push(new Cell(canvas.width / 2 - shift_x, j * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2 + shift_y, 'none', false, small_hex_len, id, i, j));
				id++;
			}
		}
		return list;
	}

	function draw_grid(grid) {
		console.debug('drawing grid');
		white_canvas();
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				if (grid[i][j].barred) {
  					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2, undefined, '#000000');
  					console.debug('filling');
  				} else if (grid[i][j].selected) {
  					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 3, '#47443c', '#d8faff');
  				} else {
  					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2);
  				}
  				if (!grid[i][j].barred && grid[i][j].aspect != 'none') {
  					console.debug('drawing image');
  					img_size = grid[i][j].side_len * 1.2;
  					//ctx.drawImage(grid[i][j].img, grid[i][j].x - img_size / 2, grid[i][j].y - img_size / 2, img_size, img_size);
  					ctx.drawImage(image_cache[grid[i][j].aspect], grid[i][j].x - img_size / 2, grid[i][j].y - img_size / 2, img_size, img_size);
  				}
  			}
  		}
	}

	/* draws a circle in the middle of each cell/tile, for debugging purposes */
	function draw_hex_centers(grid) {
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				ctx.beginPath();
				ctx.arc(grid[i][j].x, grid[i][j].y, 5, 0, 2 * Math.PI);
				ctx.stroke();
				ctx.closePath();
  			}
  		}
	}

	function assign_aspect() {
		if (selected_cell != undefined) {
			selected_cell.aspect = document.getElementById('aspect_selector').value;
			if (selected_cell.aspect != 'none') {
				var img = new Image();
				img.onload = function() {
					console.debug("loading aspect img"); 
				}
				img_size = selected_cell.side_len / 1.5;
				img.src = './hq_aspect_images_black/thaumcraft/' + selected_cell.aspect + '.png';
				image_cache[selected_cell.aspect] = img;
				selected_cell.img = image_cache[selected_cell.aspect];
				img.addEventListener("load", function () {
					draw_grid(grid);
				});
			} else {
				draw_grid(grid);
			}
		}
	}

	function preset() {
		/* base */
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				grid[i][j].aspect = 'none';
  			}
  		}
		grid[0][2].aspect = 'instrumentum';
		var img1 = new Image();
		img1.src = './hq_aspect_images_black/thaumcraft/' + grid[0][2].aspect + '.png';
		image_cache['instrumentum'] = img1;
		grid[0][2].img = image_cache['instrumentum'];

		var img2 = new Image();
		grid[2][0].aspect = 'permutatio';
		img2.src = './hq_aspect_images_black/thaumcraft/' + grid[2][0].aspect + '.png';
		image_cache['permutatio'] = img2;
		grid[2][0].img = image_cache['permutatio'];

		grid[4][2].aspect = 'metallum';
		var img3 = new Image();
		img3.src = './hq_aspect_images_black/thaumcraft/' + grid[4][2].aspect + '.png';
		image_cache['metallum'] = img3;
		grid[4][2].img = image_cache['metallum'];
		img3.addEventListener("load", function () {
			draw_grid(grid);
		});

		/* solution */
		/*var img4 = new Image();
		grid[1][1].aspect = 'vitreus';
		img4.src = './hq_aspect_images_black/thaumcraft/' + grid[1][1].aspect + '.png';
		grid[1][1].img = img4;

		var img5 = new Image();
		grid[1][2].aspect = 'ordo';
		img5.src = './hq_aspect_images_black/thaumcraft/' + grid[1][2].aspect + '.png';
		grid[1][2].img = img5;

		var img6 = new Image();
		grid[2][1].aspect = 'ordo';
		img6.src = './hq_aspect_images_black/thaumcraft/' + grid[2][1].aspect + '.png';
		grid[2][1].img = img6;

		var img7 = new Image();
		grid[2][2].aspect = 'ordo';
		img7.src = './hq_aspect_images_black/thaumcraft/' + grid[2][2].aspect + '.png';
		grid[2][2].img = img7;

		var img8 = new Image();
		grid[3][1].aspect = 'vitreus';
		img8.src = './hq_aspect_images_black/thaumcraft/' + grid[3][1].aspect + '.png';
		grid[3][1].img = img8;

		var img9 = new Image();
		grid[3][2].aspect = 'vitreus';
		img9.src = './hq_aspect_images_black/thaumcraft/' + grid[3][2].aspect + '.png';
		grid[3][2].img = img9;
		img9.addEventListener("load", function () {
			draw_grid(grid);
		});*/
	}

	var aspect_table = {
		'aer':['primal'],
		'alienis':['vacuos','tenebrae'],
		'aqua':['primal'],
		'arbor':['aer','herba'],
		'auram':['aer','praecantatio'],
		'bestia':['motus','victus'],
		'cognitio':['ignis','spiritus'],
		'corpus':['bestia','mortuus'],
		'exanimis':['motus','mortuus'],
		'fabrico':['humanus','instrumentum'],
		'fames':['vacuos','victus'],
		'gelum':['ignis','perditio'],
		'herba':['terra','victus'],
		'humanus':['bestia','cognitio'],
		'ignis':['primal'],
		'instrumentum':['ordo','humanus'],
		'iter':['terra','motus'],
		'limus':['aqua','victus'],
		'lucrum':['fames','humanus'],
		'lux':['aer','ignis'],
		'machina':['motus','instrumentum'],
		'messis':['herba','humanus'],
		'metallum':['terra','vitreus'],
		'meto':['instrumentum','messis'],
		'mortuus':['perditio','victus'],
		'motus':['aer','ordo'],
		'ordo':['primal'],
		'pannus':['bestia','instrumentum'],
		'perditio':['primal'],
		'perfodio':['terra','humanus'],
		'permutatio':['ordo','perditio'],
		'potentia':['ignis','ordo'],
		'praecantatio':['potentia','vacuos'],
		'sano':['ordo','victus'],
		'sensus':['aer','spiritus'],
		'spiritus':['victus','mortuus'],
		'telum':['ignis','instrumentum'],
		'tempestas':['aer','aqua'],
		'tenebrae':['lux','vacuos'],
		'terra':['primal'],
		'tutamen':['terra','instrumentum'],
		'vacuos':['aer','perditio'],
		'venenum':['aqua','perditio'],
		'victus':['aqua','terra'],
		'vinculum':['perditio','motus'],
		'vitium':['perditio','praecantatio'],
		'vitreus':['ordo','terra'],
		'volatus':['aer','motus']
	};

	/* Data structure for the grid: one array for each column, where each "cell" */
	/* is an object with properties like 'aspect', 'can be used', etc */
	/* Need functions for neighbour checks */

	var grid = draw_initial_grid(3);

	function compounds(aspect) {
		return aspect_table[aspect];
	}

	function inArray(haystack, needle){
		for(item in haystack){
			if (haystack[item][0] == needle[0] && haystack[item][1] == needle[1]){
				return true;
			}
		}
		return false;
	}

	function deepcopy(object) {
		if (Array.isArray(object)) {
			var copy = [];
		} else if (typeof object === "object") {
			var copy = {};
		} else {
			var copy = [];
		}
		for (index in object) {
			if (Array.isArray(object[index]) || typeof object[index] === "object") {
				copy[index] = deepcopy(object[index]);
			} else {
				copy[index] = object[index];
			}
		}
		return copy;
	}

	

	function can_connect(x1, y1, x2, y2) {
		if (grid[x2][y2].aspect == 'none') {
			return false;
		}
		if (aspect_table[grid[x1][y1].aspect].includes(grid[x2][y2].aspect) || aspect_table[grid[x2][y2].aspect].includes(grid[x1][y1].aspect)) {
			return true;
		}
		return false;
	}

	function cell_exists(x, y) {
		try {
			var i = grid[x][y].aspect;
		} catch(e) {
			return false;
		}
		if (i != undefined) {
			return true;
		}
		return false;
	}

	function paint_tiles(coord_list) {
		var real_coords = [];
		for (var i = 0; i < coord_list.length; i++) {
				real_coords.push([grid[coord_list[i][0]][coord_list[i][1]].x, grid[coord_list[i][0]][coord_list[i][1]].y]);
		}
		for (var i = 0; i < real_coords.length; i++) {
			draw_hexagon(real_coords[i][0], real_coords[i][1], grid[0][0].side_len, undefined, undefined, '#000000');
		}
	}

	function tile_neighbors(x, y, debug = false) {
		var left_coords = [[x, y - 1], [x + 1, y], [x + 1, y + 1], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var middle_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var right_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y + 1], [x - 1, y]];
		if (x == Math.floor(grid.length / 2)) {
			for (var i = 0; i < middle_coords.length; i++) {
				if (!cell_exists(middle_coords[i][0], middle_coords[i][1]) || grid[middle_coords[i][0]][middle_coords[i][1]].aspect == 'none' || !(aspect_table[grid[x][y].aspect].includes(grid[middle_coords[i][0]][middle_coords[i][1]].aspect) || aspect_table[grid[middle_coords[i][0]][middle_coords[i][1]].aspect].includes(grid[x][y].aspect))) {
					middle_coords.splice(i, 1);
					i--;
				}
			}
			return middle_coords;
		} else if (x < Math.floor(grid.length / 2)) {
			for (var i = 0; i < left_coords.length; i++) {
				if (!cell_exists(left_coords[i][0], left_coords[i][1]) || grid[left_coords[i][0]][left_coords[i][1]].aspect == 'none' || !(aspect_table[grid[x][y].aspect].includes(grid[left_coords[i][0]][left_coords[i][1]].aspect) || aspect_table[grid[left_coords[i][0]][left_coords[i][1]].aspect].includes(grid[x][y].aspect))) {
					left_coords.splice(i, 1);
					i--;
				}
			}
			return left_coords;
		}
		for (var i = 0; i < right_coords.length; i++) {
				if (!cell_exists(right_coords[i][0], right_coords[i][1]) || grid[right_coords[i][0]][right_coords[i][1]].aspect == 'none' || !(aspect_table[grid[x][y].aspect].includes(grid[right_coords[i][0]][right_coords[i][1]].aspect) || aspect_table[grid[right_coords[i][0]][right_coords[i][1]].aspect].includes(grid[x][y].aspect))) {
					right_coords.splice(i, 1);
					i--;
				}
			}
		return right_coords;
	}

	function tile_neighbors_wo_aspects(x, y, grid) {
		var left_coords = [[x, y - 1], [x + 1, y], [x + 1, y + 1], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var middle_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y], [x - 1, y - 1]];
		var right_coords = [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y + 1], [x - 1, y]];
		if (x == Math.floor(grid.length / 2)) {
			for (var i = 0; i < middle_coords.length; i++) {
				if (!cell_exists(middle_coords[i][0], middle_coords[i][1])) {
					middle_coords.splice(i, 1);
					i--;
				}
			}
			return middle_coords;
		} else if (x < Math.floor(grid.length / 2)) {
			for (var i = 0; i < left_coords.length; i++) {
				if (!cell_exists(left_coords[i][0], left_coords[i][1])) {
					left_coords.splice(i, 1);
					i--;
				}
			}
			return left_coords;
		}
		for (var i = 0; i < right_coords.length; i++) {
				if (!cell_exists(right_coords[i][0], right_coords[i][1])) {
					right_coords.splice(i, 1);
					i--;
				}
			}
		return right_coords;
	}

	/* This function only considers cell neighbours that can be connected */
	function neighbour_chain(x, y, cell_list=null) {
		//console.log(`x: ${x}, y: ${y}, cell_list: ${cell_list}`);
		if (cell_list == null) {
			cell_list = [];
		}
		if (grid[x][y].aspect != 'none' && !inArray(cell_list, [x, y])) {
			cell_list.push([x, y]);
			var neighbours = tile_neighbors(x, y);
			//console.log(`neighbours: ${neighbours}`);
			for (var i = 0; i < neighbours.length; i++) {
				//console.log(`i: ${i}, neighbor len: ${neighbours.length}`);
				neighbour_chain(neighbours[i][0], neighbours[i][1], cell_list);
			}
		}
		return cell_list;
	}

	function check_continuity(grid) {
		var starting_cell;
		var aspect_cell_counter = 0;
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				if (grid[i][j].aspect != 'none') {
  					if (starting_cell == undefined) {
  						starting_cell = [i, j];
  					}
  					aspect_cell_counter ++;
  				}
  			}
  		}
  		if (neighbour_chain(starting_cell[0], starting_cell[1]).length != aspect_cell_counter) {
  			return false;
  		}
  		return true;
	}

	function get_cell_by_id(id, grid) {
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				if (grid[i][j].id == id) {
  					return grid[i][j];
  				}
  			}
  		}
	}

	function closest_cells(grid) {
		/* basically take every cell and get all distances to all other cells */
		/* uses precalculated values */
		/* ignores cells that form a continuity */
		var current_closest_pair = [];
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				/* check that the cell has an aspect */
  				if (grid[i][j].aspect != 'none') {
  					var current_neighbour_chain = neighbour_chain(i, j);
  					for (var k = 0; k < keylen(grid[i][j].distance_dict); k++) {
  						/* check if the cell isn't already connected */
  						var in_neighbour_chain = false;
  						for (var l = 0; l < current_neighbour_chain.length; l++) {
  							if (grid[current_neighbour_chain[l][0]][current_neighbour_chain[l][1]].id == parseInt(keyAtIndex(grid[i][j].distance_dict, k))) {
  								in_neighbour_chain = true;
  							}
  						}
  						if (!in_neighbour_chain && get_cell_by_id(parseInt(keyAtIndex(grid[i][j].distance_dict, k)), grid).aspect != 'none') {
  							if (current_closest_pair.length == 0) {
  								current_closest_pair = [grid[i][j].id, parseInt(keyAtIndex(grid[i][j].distance_dict, k))];
  							} else {
  								var current_distance = get_distance(get_cell_by_id(current_closest_pair[0], grid).x, get_cell_by_id(current_closest_pair[0], grid).y, get_cell_by_id(current_closest_pair[1], grid).x, get_cell_by_id(current_closest_pair[1], grid).y);
  								var potential_distance = get_distance(grid[i][j].x, grid[i][j].y, get_cell_by_id(parseInt(keyAtIndex(grid[i][j].distance_dict, k)), grid).x, get_cell_by_id(parseInt(keyAtIndex(grid[i][j].distance_dict, k)), grid).y);
  								if (potential_distance < current_distance) {
  									current_closest_pair = [grid[i][j].id, parseInt(keyAtIndex(grid[i][j].distance_dict, k))];
  								}
  							}
  						}
  					}
  				}
  			}
  		}
  		return current_closest_pair;
	}

	function precalculate_cell_distances() {
		console.log("precalculating distances: start");
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				for (var k = 0; k < grid.length; k++) {
		  			for (var l = 0; l < grid[k].length; l++) {
		  				if (!(i == k && j == l)) {
		  					grid[i][j].distance_dict[grid[k][l].id] = get_distance(grid[i][j].x, grid[i][j].y, grid[k][l].x, grid[k][l].y);
		  				}
		  			}
		  		}
  			}
  		}
  		console.log("precalculating distances: done");
	}

	function closest_neighbor_to_cell(id1, id2, grid) {
		var cell1 = get_cell_by_id(id1, grid);
		var cell2 = get_cell_by_id(id2, grid);
		var temp_neighbors = tile_neighbors_wo_aspects(cell1.array_x, cell1.array_y, grid);
		var temp_closest_neighbour = null;
		var temp_closest_distance = null;
		for (var i = 0; i < temp_neighbors.length; i++) {
			if (grid[temp_neighbors[i][0]][temp_neighbors[i][1]].aspect == 'none' && !grid[temp_neighbors[i][0]][temp_neighbors[i][1]].barred) {
				if (temp_closest_neighbour == null) {
					temp_closest_neighbour = grid[temp_neighbors[i][0]][temp_neighbors[i][1]].id;
					temp_closest_distance = grid[temp_neighbors[i][0]][temp_neighbors[i][1]].distance_dict[id2];
				} else if (grid[temp_neighbors[i][0]][temp_neighbors[i][1]].distance_dict[id2] < temp_closest_distance) {
					temp_closest_neighbour = grid[temp_neighbors[i][0]][temp_neighbors[i][1]].id;
				}
			}
		}
		return temp_closest_neighbour;
	}

	function complexity(aspect, counter=null) {
		if (counter == null) {
			counter = 0;
		}
		counter++;
		if (aspect_table[aspect].length == 1) {
			return 0;
		} else {
			counter += Math.max(complexity(aspect_table[aspect][0]), complexity(aspect_table[aspect][1]));
		}
		return counter;
	}

	function contains(container, contained) {
		if (aspect_table[container].length == 1) {
			if (aspect_table[container][0] == contained) {
				return 0;
			}
		} else {
			if (aspect_table[container][0] == contained) {
				return 0;
			}
			if (aspect_table[container][1] == contained) {
				return 1;
			}
		}
		return -1;
	}

	function best_aspect(starting_cell_id, target_cell_id, neighbor_cell_id, grid) {
		var starting_cell = get_cell_by_id(starting_cell_id, grid);
		var target_cell = get_cell_by_id(target_cell_id, grid);
		var neighbor_cell = get_cell_by_id(neighbor_cell_id, grid);

		var least_complex_aspect = null;
		var current_complexity = null;

		/* small complexity < being linked to target cell */
		if (aspect_table[starting_cell.aspect].length == 1) {
			/* primal aspect, must choose compound that includes it */
			/* trying to have smallest complexity */
			/* and then search again to see i we can get something directly related */
			for (var i = 0; i < keylen(aspect_table); i++) {
				if (least_complex_aspect == null) {
					if (contains(keyAtIndex(aspect_table, i), starting_cell.aspect) > -1) {
						least_complex_aspect = keyAtIndex(aspect_table, i); //aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						current_complexity = complexity(least_complex_aspect);
					}
				} else {
					if (contains(keyAtIndex(aspect_table, i), starting_cell.aspect) > -1) {
						var temp_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						if (current_complexity > complexity(temp_aspect)) {
							least_complex_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
							current_complexity = complexity(least_complex_aspect);
						}
					}
				}
			}
			/* trying to match a bit the target aspect */
			for (var i = 0; i < keylen(aspect_table); i++) {
				if (contains(keyAtIndex(aspect_table, i), starting_cell.aspect) > -1) {
					if ((current_complexity == complexity(temp_aspect) || Math.abs(current_complexity - complexity(temp_aspect)) == 1) && (contains(temp_aspect, target_cell.aspect) || contains(target_cell.aspect, temp_aspect))) {
						least_complex_aspect = temp_aspect;
						current_complexity = complexity(temp_aspect);
					}
				}
			}
		} else if (aspect_table[starting_cell.aspect].length == 2) {
			/* compound aspect */
			for (var i = 0; i < keylen(aspect_table); i++) {
				if (least_complex_aspect == null) {
					if (contains(starting_cell.aspect, keyAtIndex(aspect_table, i)) > -1) {
						least_complex_aspect = keyAtIndex(aspect_table, i); //aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						current_complexity = complexity(least_complex_aspect);
					}
				} else {
					if (contains(starting_cell.aspect, keyAtIndex(aspect_table, i)) > -1) {
						var temp_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
						if (current_complexity > complexity(temp_aspect)) {
							least_complex_aspect = keyAtIndex(aspect_table, i);//aspect_table[starting_cell.aspect][contains(keyAtIndex(aspect_table, i), starting_cell.aspect)];
							current_complexity = complexity(least_complex_aspect);
						}
					}
				}
			}
			for (var i = 0; i < keylen(aspect_table); i++) {
				if (contains(starting_cell.aspect, keyAtIndex(aspect_table, i)) > -1) {
					if ((current_complexity == complexity(temp_aspect) || Math.abs(current_complexity - complexity(temp_aspect)) == 1) && (contains(temp_aspect, target_cell.aspect) || contains(target_cell.aspect, temp_aspect))) {
						least_complex_aspect = temp_aspect;
						current_complexity = complexity(temp_aspect);
					}
				}
			}
		}
		return least_complex_aspect;
	}

	function main_loop(){
		//var current_state = res[0]; var depth = res[1]; var state_history = res[2]; var original_grid = res[3]; var returning_from_bad_state = res[4]; var last_touched_cell = res[5]; var chosen_cell = res[6]; var considered_cells = res[7]; var solved = res[8];
		var used_grid = JSON.parse(JSON.stringify(current_state.grid));
		console.log(`entering depth ${depth}`);
		depth ++;
		draw_grid(used_grid);
		if (check_continuity(used_grid)) {
			solved = true;
			console.log("solved");
			//return [grid, current_state, depth, state_history, original_grid, returning_from_bad_state, last_touched_cell, chosen_cell, considered_cells, true];
		}
		if (!returning_from_bad_state) {
			console.log(`Not returning from bad state`);//, grid: ${used_grid}`);
			console.log(`impossible moves: ${current_state.impossible_moves}`);
			/* should choose two closest base cells and try to connect them. */
			/* if the algo exhausts ways to try to directly connect two cells */
			/* it should try to connect 2 other cells (on edges). */
			/* or maybe it should just try to connect 2 closest cells? */
			/* 2 closest cells: */
			var temp_closest_cells = closest_cells(used_grid);
			var first_cell = get_cell_by_id(temp_closest_cells[0], used_grid);
			var second_cell = get_cell_by_id(temp_closest_cells[1], used_grid);
			var closest_neighbour = get_cell_by_id(closest_neighbor_to_cell(first_cell.id, second_cell.id, used_grid), used_grid);
			/* then, determine the first cells neighbor that itself is closest to the second cell */
			if (temp_closest_cells.length > 0) {
				var closest_neighbour_id = closest_neighbor_to_cell(temp_closest_cells[0], temp_closest_cells[1], used_grid);
				if (closest_neighbour != null) {
					var closest_neighbour = get_cell_by_id(closest_neighbour_id, grid);
					var temp_best_aspect = best_aspect(first_cell.id, second_cell.id, closest_neighbour.id, used_grid);
					closest_neighbour.aspect = temp_best_aspect;
					var temp_img = new Image();
					temp_img.src = './hq_aspect_images_black/thaumcraft/' + temp_best_aspect + '.png';
					image_cache[temp_best_aspect] = temp_img;
					state_history.push(JSON.parse(JSON.stringify(current_state.grid)));
				} else {
					/* if no closest cell is available, blacklist that connection. */
					/* while the connection of two cells is blacklisted, they can not be elected */
					/* as two closest cells. Voilà*/
					returning_from_bad_state = true;
					last_touched_cells = [first_cell.id, second_cell.id];
					/* mark the connection somehow, so next main_loop will blacklist it, after */
					/* having popped state history */
				}
			} else {
				returning_from_bad_state = true;
				/* mark last added cell as impossible move */
			}
			
			

		} else {
			console.log(`Returning from bad state`);//, grid: ${used_grid}`);
			console.log(`last_touched_cells: ${last_touched_cells}`)
			/* if possibilities for current state exhausted, remove it from state_history */
			/* add last move to the now last state in history */
			
		}

		//console.debug(`${}`)
	}

	var current_state = new State(grid);
	var depth = 0;
	var state_history = [];
	var original_grid;// = JSON.parse(JSON.stringify(grid));//deepcopy(grid);
	var returning_from_bad_state = false;
	var last_touched_cells = null;
	var chosen_cell = null;
	var considered_cells = null;
	var solved = false;
	var max_depth = 100;

	function solve() {
		precalculate_cell_distances();
		original_grid = JSON.parse(JSON.stringify(grid));
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				if (grid[i][j].aspect != 'none') {
  					grid[i][j].base = true;
  				}
  			}
  		}
		//res = [current_state, depth, state_history, original_grid, returning_from_bad_state, last_touched_cell, chosen_cell, considered_cells, solved];
		while(solved == false && depth < max_depth) {
			main_loop();
		}
	}

</script>
</html>