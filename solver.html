<!DOCTYPE html>
<html>
<head>
	<title>GTNH TC Research Solver</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<style>
		#canvas {
			/* border: solid 1px; */
		}
	</style>
</head>
<body>
	<canvas id='canvas' onclick="handle_click(event)"></canvas>
	<br>
	<button onclick='mouse_selection_mode()'>Selection mode (for choosing aspects)</button>
	<br>
	<button onclick='mouse_barring_mode()'>Barring mode (bar the cells that aren't available)</button>
	<br>
	<select id="aspect_selector" onchange="assign_aspect()">
		<option value="none">Choose aspect</option>
		<option value="aer">Aer</option>
		<option value="alienis">Alienis</option>
		<option value="aqua">Aqua</option>
	</select>
</body>
<script>
	/* detect click outside of canvas */
	document.addEventListener('click', function(event) {
	  	var isClickInside = document.getElementById('canvas').contains(event.target) || document.getElementById('aspect_selector').contains(event.target);
	  	if (!isClickInside && selected_cell != undefined) {
	    	selected_cell.selected = false;
	    	draw_grid(grid);
	  	}
	});

	/* util functions, going into separate file later */

	/* degrees to radians */
	function to_rad(deg) {
		return deg * Math.PI / 180;
	}

	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');

	function white_canvas() {
		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	class Cell {
		constructor(x, y, aspect, barred, side_len) {
		    this.x = x;
		    this.y = y;
		    this.aspect = aspect;
		    this.barred = barred;
		    this.side_len = side_len;
		    this.selected = false;
		    this.img;
	  	}
	}

	var mouse_mode = 'selecting';
	var selected_cell;

	function mouse_selection_mode() {
		mouse_mode = 'selecting';
	}

	function mouse_barring_mode() {
		mouse_mode = 'barring';
		if (selected_cell != undefined) {
			selected_cell.selected = false;
		}
	}

	function handle_click(event) {
	  	var mouse_x = event.clientX;
	  	var mouse_y = event.clientY;
	  	var coords = "X coords: " + mouse_x + ", Y coords: " + mouse_y;
  		console.debug(coords);
  		var found = false;
  		/* loop through all cells in grid and find which one is nearest to the click */
  		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				//console.debug(grid[i][j].y);
  				console.debug(`acceptable distance: ${grid[i][j].side_len}`);
  				distance = Math.sqrt(Math.pow(Math.abs(grid[i][j].x - mouse_x), 2) + Math.pow(Math.abs(grid[i][j].y - mouse_y), 2));
  				if (distance <= grid[i][j].side_len) {
  					found = true;
  					console.debug(`found at ${parseFloat(grid[i][j].x).toFixed(2)}, ${parseFloat(grid[i][j].y).toFixed(2)} at distance ${distance}`);
  					if (mouse_mode == 'barring') {
  						if (grid[i][j].barred) {
	  						grid[i][j].barred = false;
	  					} else {
	  						grid[i][j].selected = false;
	  						grid[i][j].aspect = 'none';
	  						grid[i][j].barred = true;
	  					}
  					}
  					if (mouse_mode == 'selecting') {
  						if (grid[i][j].selected) {
	  						grid[i][j].selected = false;
	  					} else if (!grid[i][j].barred) {
	  						grid[i][j].selected = true;
	  						if (selected_cell != undefined && selected_cell != grid[i][j]) {
	  							selected_cell.selected = false;
	  						}
	  						selected_cell = grid[i][j];
	  					}
  					}
  					break;
  				}
  			}
  		}
  		if (!found && selected_cell != undefined) {
  			selected_cell.selected = false;
  		}
  		if (selected_cell != undefined && selected_cell.selected) {
  			document.getElementById('aspect_selector').value = selected_cell.aspect;
  		}
  		draw_grid(grid);
	}

	/* Resizing the canvas 31.25 percent of screen width (400 px if the screen is 1280 px wide) */
	var screen_percentage = 31.25;
	canvas.height = screen.width / 100 * screen_percentage;
	canvas.width = screen.width / 100 * screen_percentage;
	
	/* drawing default size hex grid. Regular hexagon, "size 4" */
	/* the whole grid should always take the maximum space */
	/* a place in the grid should be selected on the canvas and then the aspect that is there must be a html panel below where one can search for the aspect and click to place it */
	var grid_size = 4;

	/* Drawing hexagon at coords */
	function draw_hexagon(x, y, side_len, lineWidth = 1, lineColor = '#000000', fillColor = '#FFFFFF', pointing_up = false) {
		console.debug("side_len: " + side_len)
		side_len -= Math.ceil(lineWidth / 2) + 1;
		var triangle_height = Math.sqrt(Math.pow(side_len, 2) - Math.pow(side_len / 2, 2));
		var points;
		if (pointing_up) {
			points = [[x + triangle_height, y - side_len / 2], [x + triangle_height, y + side_len / 2], [x, y + side_len], [x - triangle_height, y + side_len / 2], [x - triangle_height, y - side_len / 2], [x, y - side_len]];
		} else {
			points = [[x + side_len / 2, y - triangle_height], [x + side_len, y], [x + side_len / 2, y + triangle_height], [x - side_len / 2, y + triangle_height], [x - side_len, y], [x - side_len / 2, y - triangle_height]];
		}
		ctx.beginPath();
		ctx.lineWidth = lineWidth;
		ctx.strokeStyle = lineColor;
		ctx.fillStyle = fillColor;
		ctx.moveTo(points[5][0], points[5][1]);
		for (var i = 0; i < points.length; i++) {
			ctx.lineTo(points[i][0], points[i][1]);
		}
		ctx.fill();
		ctx.stroke();
		ctx.closePath();
	}


	function draw_initial_grid(grid_size) {

		var hex_side_len = canvas.height / 2;
		//draw_hexagon(canvas.width / 2, canvas.height / 2, hex_side_len, undefined, undefined, undefined, true);

		var hex_num_vertical = grid_size * 2 - 1;
		var blank_num_vertical = hex_num_vertical - 1;
		console.debug("hex_num_vertical: " + hex_num_vertical + ", blank_num_vertical: " + blank_num_vertical)
		var blank_ratio = 1/10;
		var blank_len = Math.floor(canvas.height * blank_ratio / (hex_num_vertical * blank_ratio + blank_num_vertical));

		var small_hex_len_vertical = canvas.height / (hex_num_vertical + blank_num_vertical * blank_ratio);//canvas.height / hex_num_vertical - blank_len / hex_num_vertical;
		var small_hex_len = small_hex_len_vertical / 2 / Math.cos(to_rad(30));

		console.debug(`blank_len: ${blank_len}, small_hex_len_vertical: ${small_hex_len_vertical}, small_hex_len: ${small_hex_len}`);

		/*for (var i = 0; i < hex_num_vertical; i++) {
			draw_hexagon(canvas.width / 2, i * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2, small_hex_len, 2);
		}*/


		/* the number of "columns" is also the number of tiles in the middle column */
		/* the column in the middle has grid_size * 2 - 1 tiles */
		column_num = grid_size * 2 - 1;
		var list = [];
		for (var i = 0; i < column_num; i++) {
			list.push([]);
			/* number of tiles in column is grid_size + i, valid up to the middle tho.*/
			var num_of_cells_in_column;
			var shift_x;
			if (i <= Math.floor(column_num / 2)) {
				num_of_cells_in_column = grid_size + i;
				shift_x = (column_num - num_of_cells_in_column) * (1.5 * small_hex_len + blank_len);//(column_num - num_of_cells_in_column) * (small_hex_len + blank_len);
			} else {
				num_of_cells_in_column = column_num - i + grid_size - 1;
				shift_x = -(column_num - num_of_cells_in_column) * (1.5 * small_hex_len + blank_len);
			}
			console.debug("num of cells: " + num_of_cells_in_column);

			/* each row going from the center, is shifted by half a hexagone per row */
			var shift_y = (column_num - num_of_cells_in_column) * (small_hex_len_vertical / 2 + blank_len / 2);//(column_num - num_of_cells_in_column) * small_hex_len_vertical / 2 + blank_len / 2;


			for (var j = 0; j < num_of_cells_in_column; j++) {
				draw_hexagon(canvas.width / 2 - shift_x, j * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2 + shift_y, small_hex_len, 2);
				list[i].push(new Cell(canvas.width / 2 - shift_x, j * (small_hex_len_vertical + blank_len) + small_hex_len_vertical / 2 + shift_y, 'none', false, small_hex_len));
			}
		}
		return list;
	}

	function draw_grid(grid) {
		console.debug('drawing grid');
		white_canvas();
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				if (grid[i][j].barred) {
  					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2, undefined, '#000000');
  					console.debug('filling');
  				} else if (grid[i][j].selected) {
  					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 3, '#47443c', '#998b67');
  				} else {
  					draw_hexagon(grid[i][j].x, grid[i][j].y, grid[i][j].side_len, 2);
  				}
  				if (!grid[i][j].barred && grid[i][j].aspect != 'none') {
  					console.debug('drawing image');
  					ctx.drawImage(grid[i][j].img, grid[i][j].x - grid[i][j].img.width / 2, grid[i][j].y - grid[i][j].img.height / 2);
  				}
  			}
  		}
	}

	/* draws a circle in the middle of each cell/tile, for debugging purposes */
	function draw_hex_centers(grid) {
		for (var i = 0; i < grid.length; i++) {
  			for (var j = 0; j < grid[i].length; j++) {
  				ctx.beginPath();
				ctx.arc(grid[i][j].x, grid[i][j].y, 5, 0, 2 * Math.PI);
				ctx.stroke();
				ctx.closePath();
  			}
  		}
	}

	function assign_aspect() {
		if (selected_cell != undefined) {
			selected_cell.aspect = document.getElementById('aspect_selector').value;
			if (selected_cell.aspect != 'none') {
				var img = new Image();
				img.onload = function() {
					console.debug("loading aspect img"); 
				}
				img.width = selected_cell.side_len / 1.5;
				img.src = './aspect_images/' + selected_cell.aspect + '.png';
				selected_cell.img = img;
				ctx.drawImage(img, selected_cell.x - img.width / 2, selected_cell.y - img.height / 2);
				img.addEventListener("load", function () {
					draw_grid(grid);
				});
			} else {
				draw_grid(grid);
			}
		}
	}

	/* Data structure for the grid: one array for each column, where each "cell" */
	/* is an object with properties like 'aspect', 'can be used', etc */
	/* Need functions for neighbour checks */

	var grid = draw_initial_grid(3);

</script>
</html>